
// This file was automatically @generated by `isa`. Regenerate e.g. by:
// cd isa && cargo run -- md_to_rs ../doc ../server/src/generated.rs

pub static HOVERS: phf::Map<&'static str, &'static str> = ::phf::Map {
    key: 12913932095322966823,
    disps: &[
        (0, 181),
        (2, 119),
        (0, 9),
        (1, 8),
        (0, 19),
        (0, 7),
        (3, 190),
        (0, 12),
        (0, 0),
        (0, 3),
        (0, 11),
        (0, 46),
        (0, 174),
        (0, 13),
        (0, 48),
        (1, 186),
        (0, 3),
        (0, 0),
        (0, 184),
        (0, 12),
        (1, 8),
        (0, 7),
        (0, 32),
        (0, 4),
        (6, 125),
        (0, 28),
        (5, 108),
        (1, 0),
        (1, 5),
        (7, 190),
        (0, 4),
        (0, 6),
        (0, 204),
        (0, 172),
        (0, 268),
        (6, 190),
        (0, 80),
        (5, 238),
        (4, 157),
        (0, 1),
        (0, 155),
        (0, 85),
        (2, 232),
        (0, 0),
        (4, 281),
        (0, 130),
        (11, 69),
        (14, 23),
        (1, 221),
        (19, 57),
        (0, 111),
        (2, 12),
        (4, 64),
        (10, 59),
        (0, 3),
        (129, 264),
        (0, 206),
        (8, 163),
        (1, 253),
    ],
    entries: &[
        ("shl", "* `shl $mDst0, $mSrc0, $mSrc1`\n* `shl $mDst0, $mSrc0, zimm12`\n\nPerform a logical left shift, of up-to 31-bits, on a register value.\n"),
        ("put", "* `put zimm8, $mSrc0`\n\nWrite to a control register. See control_and_status_registers.\n"),
        ("$PRNG_SEED", "Writes to this register cause the following assignments to the \\$PRNG\nstate:\n\n-   `$PRNG_0_0` =value\n-   `$PRNG_0_1` = \\~value\n-   `$PRNG_1_0` = (value \\<\\< 13) \\| (\\~value \\>\\> 19)\n-   `$PRNG_1_1` = (\\~value \\<\\< 13) \\| (value \\>\\> 19)\n\nReads return 0.\n"),
        ("cmpeq", "* `cmpeq $mDst0, $mSrc0, $mSrc1`\n* `cmpeq $mDst0, $mSrc0, zimm16`\n* `cmpeq $mDst0, $mSrc0, simm16`\n\n*Equality* comparison of two source values. The destination is set to 1\nif the two source operands are equal. Otherwise the destination register\nis set to 0.\n"),
        ("$m4", "`$m4` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("f16v2exp", "* `f16v2exp $aDst0, $aSrc0`\n\n\n"),
        ("xor", "* `xor $mDst0, $mSrc0, $mSrc1`\n\nBitwise-XOR of two register values.\n"),
        ("urand64", "* `urand64 $aDst0:Dst0+1`\n\nUniform distribution, 64-bit random integer.\n"),
        ("$PRNG_1_0", "The least significant 32-bits of \\$PRNG_1.\n\n## Note\n\nThe value of this register is retained between worker exit and launch.\n"),
        ("$m0", "`$m0` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("f32v2cmpgt", "* `f32v2cmpgt $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2cmpgt $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector greater-than test\n"),
        ("f32oorx", "* `f32oorx $aDst0, $aSrc0`\n\n*Single-precision* reciprocal of square-root.\n"),
        ("f32mac", "* `f32mac $aSrc0, $aSrc1`\n\n*Single-precision* floating-point multiplication of two source registers\nwith *single-precision* accumulate.\n"),
        ("f32ln", "* `f32ln $aDst0, $aSrc0`\n\n\n"),
        ("exitz", "* `exitz $mSrc0`\n\nTerminate current execution of a *Worker* thread and return a Boolean\nexit status to the *Supervisor* thread. This instruction passes control\nfrom a *Worker* thread to the *Supervisor* thread. The currently\nallocated thread execution slot is returned to the *Supervisor*, which\nmay reassign the execution slot to another task.\n\n## Note\n\nThis instruction considers the floating-point *single-precision* value\n-0.0 to not be zero (+0.0)\n"),
        ("f32sqrt", "* `f32sqrt $aDst0, $aSrc0`\n\nComputes the square root of a single precision floating-point register\nsource.\n"),
        ("or", "* `or $mDst0, $mSrc0, $mSrc1`\n* `or $mDst0, $mSrc0, zimm12`\n* `or $mDst0, $mSrc0, immz12`\n* `or $aDst0, $aSrc0, $aSrc1`\n* `or $aDst0, $aSrc0, zimm12`\n* `or $aDst0, $aSrc0, immz12`\n\nCompute the bitwise-OR of 1 32-bit register source value with 1 32-bit\nregister or 1 *zero extended*/*zero tailed* 12-bit immediate value.\n"),
        ("f16v4sihoamp", "* `f16v4sihoamp $aDst0, $aSrc0:Src0+1, $aSrc1:Src1+1, enumFlags`\n\n*Half-precision* floating-point vector accumulating matrix-vector\nproduct. Input partial-sums are *single-precision*. Result values are\n*half-precision*.\n"),
        ("$mvertex_base", "The Vertex Base Register (an alias for `$m13`). Initialised on behalf of a Worker context by the Supervisor via `run` or `runall`.\n"),
        ("f32v2tof16", "* `f32v2tof16 $aDst0, $aSrc0:Src0+1`\n\n*Single-precision* floating-point pair to *f16* conversion\n"),
        ("ld32step", "* `ld32step $mDst0, $mBase0, $mDelta0+=, simm8`\n* `ld32step $mDst0, $mBase0, $mDelta0+=, $mStride0`\n* `ld32step $aDst0, $mBase0, $mDelta0+=, simm8`\n* `ld32step $aDst0, $mBase0, $mDelta0+=, $mStride0`\n\nNaturally aligned single *word* load with scaled post-incrementing\naddress.\n\nDestination register-file: MRF or ARF\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nData format:\n\n:   -   Result is an unmodified 32-bit value.\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register\n        (after the value has been scaled to atom size).\n"),
        ("shuf8x8hi", "* `shuf8x8hi $mDst0, $mSrc0, $mSrc1`\n\nPerform SIMD *shuffle* permutation on 8 x 8-bit values, across 2 source\nregisters, returning the upper *word* of the result. See [shuf8x8lo]()\nfor lower *word*.\n"),
        ("br", "* `br $mSrc0`\n\nUnconditional absolute branch to register target address.\n"),
        ("f16v4sufromui", "* `f16v4sufromui $aDst0:Dst0+1, $aSrc0:Src0+1`\n\nSymmetric, unbiased conversion from 4-element vector of unsigned 16-bit\nintegers to 4-element *half-precision* vector.\n\nEach of the *half-precision* results lies within the range\n\\$\\[-frac{1}{2}, frac{1}{2}\\]\\$ but can never be exactly 0. The minimum\nresult magnitude is \\$frac{1}{2\\^{17}}\\$ (and therefore results can lie\nwithin the denormalised number range for *half-precision*).\n\nNote that this instruction can be combined with `urand32`/`urand64` to\nproduce random, uniformly distributed floating-point values.\n"),
        ("st32", "* `st32 $aSrc0, $mBase0, $mDelta0, $mOffset0`\n* `st32 $mSrc0, $mBase0, $mDelta0, zimm12`\n* `st32 $aSrc0, $mBase0, $mDelta0, zimm12`\n\nStore a single 32-bit register value toTile Memory.\n\nSource register-file: MRF or ARF\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n"),
        ("f32v2absmax", "* `f32v2absmax $aDst0:Dst0+1, $aSrc1:Src1+1, $aSrc0:Src0+1`\n\n*Single-precision* 2-element vector element-wise max of absolute values.\n"),
        ("f32sub", "* `f32sub $aDst0, $aSrc0, $aSrc1`\n\nSubtracts two floating-point values.\n"),
        ("add", "* `add $mDst0, $mSrc0, $mSrc1`\n* `add $mDst0, $mSrc0, zimm16`\n* `add $mDst0, $mSrc0, simm16`\n\nSigned integer addition of 2 source register values, or 1 source\nregister and 1 immediate. Immediates may be *sign extended* or *zero\nextended* to *word* width. No scaling of the source operands (register\nor immediate) is performed.\n"),
        ("f16v2sum", "* `f16v2sum $aDst0, $aSrc0`\n\n*Half-precision* 2-element vector lateral summation to\n*single-precision*.\n"),
        ("f16v2cmplt", "* `f16v2cmplt $aDst0, $aSrc0, $aSrc1`\n* `f16v2cmplt $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2cmplt $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* floating-point vector less-than test\n"),
        ("$PC", "Context Program Counter.\n\n## Note\n\nFor Worker contexts, the initial value of this register following worker\nlaunch is set by the Supervisor run instruction.\n"),
        ("$CTXT_STS", "See `$CTXT_STS`\n"),
        ("f16v2sub", "* `f16v2sub $aDst0, $aSrc0, $aSrc1`\n* `f16v2sub $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2sub $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* floating-point vector subtract\n"),
        ("popc", "* `popc $mDst0, $mSrc0`\n\nEstablishes the number of set bits in a 32-bit register source value.\n"),
        ("$PRNG_1_1", "The most significant 32-bits of \\$PRNG_1.\n\n## Note\n\nThe value of this register is retained between worker exit and launch.\n"),
        ("ld64a32", "* `ld64a32 $aDst0+1:Dst0+3, $mAddr0++, $mBase0, $mDelta0`\n\nPost-incrementing load of dense 64-bit value plus a sparse 32-bit value.\n\nDestination register-file: ARF only\n\nEffective addresses:\n\n:   1.  A full-pointer register value (notionally a pointer into an\n        array of dense values).\n    2.  A base address register value added to a 16-bit delta-offset\n        located in the lsbs of a third source register value.\n\nData format:\n\n:   -   Results are:\n        -   A naturally aligned 64-bit value, written to the top half of\n            the destination register quad.\n        -   A naturally aligned 32-bit data value, written to the 2nd\n            element of the destination register quad.\n\nAddress auto-increment:\n\n:   -   The full-pointer register is post-incremented by 8 (bytes)\n\n## Note\n\nThe first element of the destination register quad is unmodified.\n"),
        ("sort8", "* `sort8 $mDst0, $mSrc0`\n\nPerform SIMD *sort8* permutation on 4 x 8-bit values.\n"),
        ("f16v2sufromui", "* `f16v2sufromui $aDst0, $aSrc0`\n\nSymmetric, unbiased conversion from 2-element vector of unsigned 16-bit\nintegers to 2-element *half-precision* vector.\n\nEach of the *half-precision* results lies within the range\n\\$\\[-frac{1}{2}, frac{1}{2}\\]\\$ but can never be exactly 0. The minimum\nresult magnitude is \\$frac{1}{2\\^{17}}\\$ (and therefore results can lie\nwithin the denormalised number range for *half-precision*).\n\nNote that this instruction can be combined with `urand32`/`urand64` to\nproduce random, uniformly distributed floating-point values.\n"),
        ("lds16step", "* `lds16step $mDst0, $mBase0, $mDelta0+=, simm8`\n* `lds16step $mDst0, $mBase0, $mDelta0+=, $mStride0`\n\nSign-extending, naturally aligned 16-bit load with scaled\npost-incrementing address.\n\nDestination register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nData format:\n\n:   -   Result is a 32-bit value formed by sign-extending the 16-bit\n        data value.\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register\n        (after the value has been scaled to atom size).\n"),
        ("f16tof32", "* `f16tof32 $aDst0, $aSrc0`\n\nConvert a *f16* value to *single-precision*.\n"),
        ("f32cmpgt", "* `f32cmpgt $aDst0, $aSrc0, $aSrc1`\n\nTest if a floating-point number is greater than a second floating-point\nnumber. If so, the destination register is set to , otherwise it is set\nto .\n"),
        ("f32v2class", "* `f32v2class $aDst0, $aSrc0:Src0+1`\n\n*Single-precision* floating-point vector classifier. IEEE 754-2008:\n5.7.2\n"),
        ("f16v2min", "* `f16v2min $aDst0, $aSrc0, $aSrc1`\n\n*Half-precision* floating-point vector element-wise minimum\n"),
        ("f32int", "* `f32int $aDst0, $aSrc1, enumRnd`\n\nRound a *single-precision* floating-point value to an integral, rounding\nas specified by the instruction immediate.\n"),
        ("f32div", "* `f32div $aDst0, $aSrc0, $aSrc1`\n\nFloating-point division of two register source values.\n"),
        ("exitneg", "* `exitneg $mSrc0`\n\nTerminate current execution of a *Worker* thread and return a Boolean\nexit status to the *Supervisor* thread. This instruction passes control\nfrom a *Worker* thread to the *Supervisor* thread. The currently\nallocated thread execution slot is returned to the *Supervisor*, which\nmay reassign the execution slot to another task.\n"),
        ("movz", "* `movz $mSrcDst0, $mSrc0, $mSrc1`\n\nConditional copy of one register into another, gated on the value of a\nthird.\n"),
        ("$a2", "`$a2` general purpose arithmetic register.\n"),
        ("ldz8step", "* `ldz8step $mDst0, $mBase0, $mDelta0+=, simm8`\n* `ldz8step $mDst0, $mBase0, $mDelta0+=, $mStride0`\n\nZero-extending 8-bit load with post-incrementing address.\n\nDestination register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nData format:\n\n:   -   Result is a 32-bit value formed by zero-extending the 8-bit data\n        value.\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register.\n"),
        ("not64", "* `not64 $aDst0:Dst0+1, $aSrc0:Src0+1`\n\nCompute the bitwise logical NOT of a 64-bit ARF register-pair.\n"),
        ("f32v2min", "* `f32v2min $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Single-precision* 2-element vector element-wise minimum\n"),
        ("call", "* `call $mDst0, zimm20`\n\nUnconditional absolute branch and link. Save the next value of **\\$PC**\ninto a general purpose register and perform an unconditional branch.\nImmediate provides word-addressed absolute destination address.\n\n## Note\n\nBit 19 of the immediate is ignored\n"),
        ("f32exp2", "* `f32exp2 $aDst0, $aSrc0`\n\n\n"),
        ("$COUNT_U", "[Tile]{.title-ref} cycle counter value. Upper 32-bits\n"),
        ("$WORKER_BASE", "Worker context scratch space base address. Read alias of Supervisor\n**\\$WORKER\\<***ctxtId***\\>\\_BASE**.\n"),
        ("$m1", "`$m1` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("sort4x16lo", "* `sort4x16lo $mDst0, $mSrc0, $mSrc1`\n* `sort4x16lo $aDst0, $aSrc0, $aSrc1`\n* `sort4x16lo $aDst0, $aSrc0:BU, $aSrc1`\n\nPerform SIMD *sort* permutation on 4 x 16-bit values, across 2 source\nregisters, producing a 2 x 16-bit result.\n"),
        ("f32v2sufromui", "* `f32v2sufromui $aDst0:Dst0+1, $aSrc0:Src0+1`\n\nSymmetric, unbiased conversion from 2-element vector of unsigned 32-bit\nintegers to 2-element *single-precision* vector.\n\nEach of the *single-precision* results lies within the range\n\\$\\[-frac{1}{2}, frac{1}{2}\\]\\$ but can never be exactly 0. All results\nwill have a magnitude of at least \\$frac{1}{2\\^{33}}\\$ (and therefore\nresults will never be inside the denormalised number range for\n*single-precision*).\n\nNote that this instruction can be combined with `urand32`/`urand64` to\nproduce random, uniformly distributed floating-point values.\n"),
        ("$VERTEX_BASE", "Vertex data structure pointer. Initialised on behalf of a Worker context\nby the Supervisor via or . This register can also be read through an MRF\nalias.\n"),
        ("brnz", "* `brnz $mSrc0, zimm19`\n\nConditional branch to absolute address. Branch taken if and only if\nregister value **is not 0**. Immediate provides word-addressed absolute\ndestination address.\n\n## Note\n\nThis instruction considers the floating-point *single-precision* value\n-0.0 to not be zero (+0.0)\n"),
        ("ldd16v2a32", "* `ldd16v2a32 $aDst0, $mAddr0++, $mBase0, $mDelta0@`\n\nPost-incrementing load of dense 16-bit delta-pair plus a sparse 32-bit\ndata value.\n\nDestination register-file: ARF only\n\nEffective addresses:\n\n:   1.  A full-pointer register value (notionally a pointer into an\n        array of 16-bit deltas)\n    2.  A base address register value added to a 16-bit delta-offset\n        located in the msbs of a third source register value.\n\nData format:\n\n:   -   Results are:\n        -   A new pair of 16-bit deltas\n        -   A naturally aligned 32-bit data value, written to the\n            destination register\n\nAddress auto-increment:\n\n:   -   The full pointer register is post-incremented by 4 (bytes)\n"),
        ("f16v4cmple", "* `f16v4cmple $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4cmple $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4cmple $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector less-than or equal-to test\n"),
        ("roll32", "* `roll32 $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\nPerform a SIMD *roll* permutation on the 4 x 32-bit values across 2\nsource registers-pairs.\n"),
        ("rpt", "* `rpt $mSrc0, zimm8`\n* `rpt zimm12, zimm8`\n\n*rpt* provides a zero-overhead loop facility, causing the subsequent\nsequence of *Execution Bundle*s (the repeat-body) to be executed\nrepeatedly. The repeat-count can be provided as an immediate or as an\nunsigned register source value. The size of the repeat-body is expressed\nin whole Execution Bundles and provided by an immediate (with the\nrepeat-body size being (immediate + 1) *Execution Bundle*s). Note that\nit is not possible to execute solo instructions within a repeat-body. A\n*exception* will be raised in an attempt to execute a solo instruction.\n\nIf the repeat-count is zero initially, *rpt* will act as a branch over\nthe repeat-body. Otherwise, the subsequent repeat-body *Execution\nBundle*s will be executed repeat-count times.\n\nAny instruction co-issued with *rpt* is executed only once, and is not\npart of the repeat-body.\n\n`control` and `system` instructions cannot be executed within the\nrepeat-body. A exception will be raised in an attempt to execute any\nsuch instruction within the body of *rpt*.\n\nExceptions raised during the execution of the repeat-body will always be\ntreated as malign, regardless of the underlying exception type\n(including Debug exceptions). When such exceptions arise, `$WSR.ERPT` is\nset to 0b1 to indicate that the event is unrecoverable.\n"),
        ("lds8step", "* `lds8step $mDst0, $mBase0, $mDelta0+=, simm8`\n* `lds8step $mDst0, $mBase0, $mDelta0+=, $mStride0`\n\nSign-extending 8-bit load with post-incrementing address.\n\nDestination register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nData format:\n\n:   -   Result is a 32-bit value formed by sign-extending the 8-bit data\n        value.\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register.\n"),
        ("f32mul", "* `f32mul $aDst0, $aSrc0, $aSrc1`\n\nSingle precision floating-point multiplication on 2 source register\nvalues.\n"),
        ("f16v2absmax", "* `f16v2absmax $aDst0, $aSrc1, $aSrc0`\n\n*Half-precision* floating-point vector max of absolute values\n"),
        ("f16v4gacc", "* `f16v4gacc $aDst0:Dst0+1`\n\nGet accumulators.\n\nRead 4 internal accumulator values as a *half-precision* vector.\n"),
        ("f16v4hihoslic", "* `f16v4hihoslic $aDst0, $aSrc0:Src0+1, $aSrc1, enumFlags`\n\n*Half-precision* floating-point vector slim convolution.\n\nInput partial-sums are *half-precision*. Results are *half-precision*\n\n::: tabularcolumns\np{dimexpr 0.07linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}p{dimexpr 0.05linewidth-2tabcolsep}\n\n::: rst-class\nfullwidth\n\n  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  \\$aSrc0\\|1    \\$AACC\\[14\\]   \\$AACC\\[10\\]           \\$AACC\\[6\\]         \\$AACC\\[2\\]        \\$AACC\\[12\\]   \\$AACC\\[8\\]            \\$AACC\\[4\\]         \\$AACC\\[0\\]        \\$aDst0\n  ------------- -------------- ---------------------- ------------------- ------------------ -------------- ---------------------- ------------------- ------------------ ---------\n  x0\\|P0,P1     **-**          R1=x0.**CW**5,0+P1     **-**               **-**              **-**          R0=x0.**CW**4,0+P0     **-**               **-**              **-**\n\n  x1\\|P2,P3     **-**          R3=x1.**CW**5,0+P3     R1+=x1.**CW**3,0    **-**              **-**          R2=x1.**CW**4,0+P2     R0+=x1.**CW**2,0    **-**              **-**\n\n  x2\\|P4,P5     **-**          R5=x2.**CW**5,0+P5     R3+=x2.**CW**3,0    R1+=x2.**CW**1,0   **-**          R4=x2.**CW**4,0+P4     R2+=x2.**CW**2,0    R0+=x2.**CW**0,0   **-**\n\n  x3\\|P6,P7     **-**          R7=x3.**CW**5,0+P7     R5+=x3.**CW**3,0    R3+=x3.**CW**1,0   **-**          R6=x3.**CW**4,0+P6     R4+=x3.**CW**2,0    R2+=x3.**CW**0,0   R0,R1\n\n  x4\\|P8,P9     **-**          R9=x4.**CW**5,0+P9     R7+=x4.**CW**3,0    R5+=x4.**CW**1,0   **-**          R8=x4.**CW**4,0+P8     R6+=x4.**CW**2,0    R4+=x4.**CW**0,0   R2,R3\n\n  x5\\|P10,P11   **-**          R11=x5.**CW**5,0+P11   R9+=x5.**CW**3,0    R7+=x5.**CW**1,0   **-**          R10=x5.**CW**4,0+P10   R8+=x5.**CW**2,0    R6+=x5.**CW**0,0   R4,R5\n\n  x6\\|P12,P13   **-**          R13=x6.**CW**5,0+P13   R11+=x6.**CW**3,0   R9+=x6.**CW**1,0   **-**          R12=x6.**CW**4,0+P12   R10+=x6.**CW**2,0   R8+=x6.**CW**0,0   R6,R7\n  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n  : f16v4hihoslic, 2x1x3x4 example sequence\n\n::: tabularcolumns\np{dimexpr 0.07linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}p{dimexpr 0.05linewidth-2tabcolsep}\n\n::: rst-class\nfullwidth\n\n  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  \\$aSrc0\\|1    \\$AACC\\[14\\]           \\$AACC\\[10\\]        \\$AACC\\[6\\]        \\$AACC\\[2\\]        \\$AACC\\[12\\]           \\$AACC\\[8\\]         \\$AACC\\[4\\]        \\$AACC\\[0\\]        \\$aDst0\n  ------------- ---------------------- ------------------- ------------------ ------------------ ---------------------- ------------------- ------------------ ------------------ ---------\n  x0\\|P0,P1     R1=x0.**CW**7,0+P1     **-**               **-**              **-**              R0=x0.**CW**6,0+P0     **-**               **-**              **-**              **-**\n\n  x1\\|P2,P3     R3=x1.**CW**7,0+P3     R1+=x1.**CW**5,0    **-**              **-**              R2=x1.**CW**6,0+P2     R0+=x1.**CW**4,0    **-**              **-**              **-**\n\n  x2\\|P4,P5     R5=x2.**CW**7,0+P5     R3+=x2.**CW**5,0    R1+=x2.**CW**3,0   **-**              R4=x2.**CW**6,0+P4     R2+=x2.**CW**4,0    R0+=x2.**CW**2,0   **-**              **-**\n\n  x3\\|P6,P7     R7=x3.**CW**7,0+P7     R5+=x3.**CW**5,0    R3+=x3.**CW**3,0   R1+=x3.**CW**1,0   R6=x3.**CW**6,0+P6     R4+=x3.**CW**4,0    R2+=x3.**CW**2,0   R0+=x3.**CW**0,0   **-**\n\n  x4\\|P8,P9     R9=x4.**CW**7,0+P9     R7+=x4.**CW**5,0    R5+=x4.**CW**3,0   R3+=x4.**CW**1,0   R8=x4.**CW**6,0+P8     R6+=x4.**CW**4,0    R4+=x4.**CW**2,0   R2+=x4.**CW**0,0   R0,R1\n\n  x5\\|P10,P11   R11=x5.**CW**7,0+P11   R9+=x5.**CW**5,0    R7+=x5.**CW**3,0   R5+=x5.**CW**1,0   R10=x5.**CW**6,0+P10   R8+=x5.**CW**4,0    R6+=x5.**CW**2,0   R4+=x5.**CW**0,0   R2,R3\n\n  x6\\|P12,P13   R13=x6.**CW**7,0+P13   R11+=x6.**CW**5,0   R9+=x6.**CW**3,0   R7+=x6.**CW**1,0   R12=x6.**CW**6,0+P12   R10+=x6.**CW**4,0   R8+=x6.**CW**2,0   R6+=x6.**CW**0,0   R4,R5\n  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n  : f16v4hihoslic, 1x4 example sequence\n\nPn is *half-precision* input partial-sum *n* xn is an *f16v4* input\nvector **CW**m,n is the common weight state **\\$CWEI**\\_*m*\\_*n* Rn is\nthe final *half-precision* result of successive dot-product\naccumulations that began with Pn\n"),
        ("f16v2grand", "* `f16v2grand $aDst0`\n\nGaussian distribution, 2-element *half-precision* random vector\n"),
        ("mul", "* `mul $mDst0, $mSrc0, $mSrc1`\n* `mul $mDst0, $mSrc0, simm16`\n\nMultiply a signed 32-bit register source value with a signed 32-bit\nregister or sign extended 16-bit immediate.\n"),
        ("$a7", "`$a7` general purpose arithmetic register.\n"),
        ("f32fromi32", "* `f32fromi32 $aDst0, $aSrc0`\n\nConvert a signed integer to a *single-precision* floating-point value.\n"),
        ("f16v2gina", "* `f16v2gina $aDst0, $aSrc0, zimm12`\n\nGet and initialise accumulators.\n\n-   Read a pair of internal accumulator values as *half-precision*\n    values. Stochastic rounding applies as configured by\n    `$FP_CTL.ESR`.\n>\n-   Convert 2-element vector of *half-precision* input values to\n    single precision and write to internal accumulator state.\n>\n-   The instruction immediate specifies which pair of accumulator\n    registers are to be read and written:\n>\n    > a.  Read **\\$AACC**\\[0\\] and **\\$AACC**\\[2\\], write\n    >     **\\$AACC**\\[12\\] and **\\$AACC**\\[14\\]\n    > b.  Read **\\$AACC**\\[1\\] and **\\$AACC**\\[3\\], write\n    >     **\\$AACC**\\[13\\] and **\\$AACC**\\[15\\]\n    >\n    > and if and only if the platform supports 2 AMP sets:\n    >\n    > c.  Read **\\$AACC**\\[16\\] and **\\$AACC**\\[18\\], write\n    >     **\\$AACC**\\[28\\] and **\\$AACC**\\[30\\]\n    > d.  Read **\\$AACC**\\[17\\] and **\\$AACC**\\[19\\], write\n    >     **\\$AACC**\\[29\\] and **\\$AACC**\\[31\\]\n>\n-   Propagate internal accumulator state such that all accumulator\n    registers may be read and written via a sequence of this\n    instruction.\n\nzimm12 immediate format:\n\n![f16v2gina immediate\nformat](images/autogen/GINA_IMMFLAGS.*){.align-center}\n"),
        ("$CCCSLOAD", "Post-incrementing load address for `ld64putcs` and `ld128putcs`.\n"),
        ("$azeros", "Alias for `$a14:15`. This register is read-only and always returns 0.\n"),
        ("stm32step", "* `stm32step $mSrc0, $mBase0+=, $mStride0`\n\nNaturally aligned 32-bit store from MRF with scaled post-incrementing\naddress.\n\nSource register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n\nAddress auto-increment:\n\n:   -   The base address register operand is post-incremented by the\n        signed stride register value (after the value has been scaled to\n        atom size).\n"),
        ("xnor", "* `xnor $mDst0, $mSrc0, $mSrc1`\n\nThe complement of the bitwise-XOR of two register values.\n"),
        ("f16v4class", "* `f16v4class $aDst0, $aSrc0:Src0+1`\n\n*Half-precision* floating-point vector classifier. IEEE 754-2008: 5.7.2\n"),
        ("$a15", "`$a15` register. Always reads 0. You probably meant to use `$azero` or `$azeros`.\n"),
        ("$m13", "`$m13` Vertex Base Register. Initialised on behalf of a Worker context by the Supervisor via `run` or `runall`. This register can also be read through the `$vertex_base` alias.\n"),
        ("f16v4hihoamp", "* `f16v4hihoamp $aDst0, $aSrc0:Src0+1, $aSrc1, enumFlags`\n\n*Half-precision* floating-point vector accumulating matrix-vector\nproduct. Input partial-sum and result values are *half-precision*.\n\n::: tabularcolumns\np{dimexpr 0.07linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}p{dimexpr 0.05linewidth-2tabcolsep}\n\n::: rst-class\nfullwidth\n\n  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  \\$aSrc0\\|1     \\$AACC\\[14\\]            \\$AACC\\[12\\]            \\$AACC\\[10\\]            \\$AACC\\[8\\]             \\$AACC\\[6\\]             \\$AACC\\[4\\]             \\$AACC\\[2\\]             \\$AACC\\[0\\]             \\$aDst0\n  -------------- ----------------------- ----------------------- ----------------------- ----------------------- ----------------------- ----------------------- ----------------------- ----------------------- ---------\n  0[^1]\\|P0,P1   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**\n\n  0\\|P2,P3       **-**                   **-**                   **-**                   \\[**WARM-UP**           **PERIOD**\\]            **-**                   **-**                   **-**                   **-**\n\n  0\\|P4,P5       **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**\n\n  0\\| P6,P7      **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**\n\n  x0\\|P8,P9      R7=x0.**CW**7,0+P7      R6=x0.**CW**6,0+P6      R5=x0.**CW**5,0+P5      R4=x0.**CW**4,0+P4      R3=x0.**CW**3,0+P3      R2=x0.**CW**2,0+P2      R1=x0.**CW**1,0+P1      R0=x0.**CW**0,0+P0      **-**\n\n  x1\\|P10,P11    R7+=x1.**CW**7,1        R6+=x1.**CW**6,1        R5+=x1.**CW**5,1        R4+=x1.**CW**4,1        R3+=x1.**CW**3,1        R2+=x1.**CW**2,1        R1+=x1.**CW**1,1        R0+=x1.**CW**0,1        **-**\n\n  x2\\|P12,P13    R7+=x2.**CW**7,2        R6+=x2.**CW**6,2        R5+=x2.**CW**5,2        R4+=x2.**CW**4,2        R3+=x2.**CW**3,2        R2+=x2.**CW**2,2        R1+=x2.**CW**1,2        R0+=x2.**CW**0,2        **-**\n\n  x3\\|P14,P15    R7+=x3.**CW**7,3        R6+=x3.**CW**6,3        R5+=x3.**CW**5,3        R4+=x3.**CW**4,3        R3+=x3.**CW**3,3        R2+=x3.**CW**2,3        R1+=x3.**CW**1,3        R0+=x3.**CW**0,3        **-**\n\n  x4\\|P16,P17    R15=x4.**CW**7,0+P15    R14=x4.**CW**6,0+P14    R13=x4.**CW**5,0+P13    R12=x4.**CW**4,0+P12    R11=x4.**CW**3,0+P11    R10=x4.**CW**2,0+P10    R9=x4.**CW**1,0+P9      R8=x4.**CW**0,0+P8      R0,R1\n\n  x5\\|P18,P19    R15+=x5.**CW**7,1       R14+=x5.**CW**6,1       R13+=x5.**CW**5,1       R12+=x5.**CW**4,1       R11+=x5.**CW**3,1       R10+=x5.**CW**2,1       R9+=x5.**CW**1,1        R8+=x5.**CW**0,1        R2,R3\n\n  x6\\|P20,P21    R15+=x6.**CW**7,2       R14+=x6.**CW**6,2       R13+=x6.**CW**5,2       R12+=x6.**CW**4,2       R11+=x6.**CW**3,2       R10+=x6.**CW**2,2       R9+=x6.**CW**1,2        R8+=x6.**CW**0,2        R4,R5\n\n  x7\\|P22,P23    R15+=x7.**CW**7,3       R14+=x7.**CW**6,3       R13+=x7.**CW**5,3       R12+=x7.**CW**4,3       R11+=x7.**CW**3,3       R10+=x7.**CW**2,3       R9+=x7.**CW**1,3        R8+=x7.**CW**0,3        R6,R7\n\n  x8\\|P24,P25    R23=x8.**CW**7,0+P23    R22=x8.**CW**6,0+P22    R21=x8.**CW**5,0+P21    R20=x8.**CW**4,0+P20    R19=x8.**CW**3,0+P19    R18=x8.**CW**2,0+P18    R17=x8.**CW**1,0+P17    R16=x8.**CW**0,0+P16    R8,R9\n\n  x9\\|P26,P27    R23+=x9.**CW**7,1       R22+=x9.**CW**6,1       R21+=x9.**CW**5,1       R20+=x9.**CW**4,1       R19+=x9.**CW**3,1       R18+=x9.**CW**2,1       R17+=x9.**CW**1,1       R16+=x9.**CW**0,1       R10,R11\n\n  x10\\|P28,P29   R23+=x10.**CW**7,2      R22+=x10.**CW**6,2      R21+=x10.**CW**5,2      R20+=x10.**CW**4,2      R19+=x10.**CW**3,2      R18+=x10.**CW**2,2      R17+=x10.**CW**1,2      R16+=x10.**CW**0,2      R12,R13\n\n  x11\\|P30,P31   R23+=x11.**CW**7,3      R22+=x11.**CW**6,3      R21+=x11.**CW**5,3      R20+=x11.**CW**4,3      R19+=x11.**CW**3,3      R18+=x11.**CW**2,3      R17+=x11.**CW**1,3      R16+=x11.**CW**0,3      R14,R15\n\n  x12\\|P32,P33   R31=x12.**CW**7,0+P31   R30=x12.**CW**6,0+P30   R29=x12.**CW**5,0+P29   R28=x12.**CW**4,0+P28   R27=x12.**CW**3,0+P27   R26=x12.**CW**2,0+P26   R25=x12.**CW**1,0+P25   R24=x12.**CW**0,0+P24   R16,R17\n  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n  : f16v4hihoamp 8x1x1x16 example sequence\n\nPn is *half-precision* input partial-sum *n* xn is an *f16v4* input\nvector **CW**m,n is the common weight state **\\$CWEI**\\_*m*\\_*n* Rn is\nthe final *half-precision* result of successive dot-product\naccumulations that began with Pn\n\n[^1]: 0 input used to fill AMP pipeline during warm-up period\n"),
        ("$m5", "`$m5` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("f32cmpge", "* `f32cmpge $aDst0, $aSrc0, $aSrc1`\n\nTest if a floating-point number is greater than or equal to a second\nfloating-point number. If so, the destination register is set to ,\notherwise it is set to .\n"),
        ("ld128putcs", "* `ld128putcs zimm8`\n\nLoad a naturally aligned 128-bit quantity, from a memory region with an\n*interleave factor* of at least 2 and write the value to the common\ncompute configuration space. The load address is provided by\n`$CCCSLOAD`, which is automatically post-incremented by 16.\n"),
        ("f32clamp", "* `f32clamp $aDst0, $aSrc0, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector min-of-maximum\n"),
        ("sort8x8lo", "* `sort8x8lo $mDst0, $mSrc0, $mSrc1`\n\nPerform SIMD *sort* permutation on 8 x 8-bit values, across 2 source\nregisters, returning the lower *word* of the result. See [sort8x8hi]()\nfor upper *word*.\n"),
        ("f16v4mul", "* `f16v4mul $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4mul $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4mul $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector, Hadamard product\n"),
        ("$fp", "Alias for `$m5`. Frame Pointer. Points to the part of the stack used by the current function.\n"),
        ("shrs", "* `shrs $mDst0, $mSrc0, $mSrc1`\n* `shrs $mDst0, $mSrc0, zimm12`\n\nPerform an arithmetic right shift (the sign-bit is shifted in), of up-to\n31-bits, on a register value.\n"),
        ("f16v4mix", "* `f16v4mix $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector **z** = *a***x** + *b***y**. The\nscalar multiplicands *a* and *b* are provided by the internal state\nelement `$TAS`.\n\nResults are stored within the accumulator state. Destination registers\nare written with the previous accumulator state.\n"),
        ("f16v2tof32", "* `f16v2tof32 $aDst0:Dst0+1, $aSrc0`\n\n*f16* floating-point pair to *single-precision* conversion\n"),
        ("f32v4acc", "* `f32v4acc $aSrc0:Src0+3`\n\n*Single-precision* 4-element vector accumulation to *Single-precision*.\n"),
        ("f16v4min", "* `f16v4min $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector element-wise minimum\n"),
        ("andc64", "* `andc64 $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n64-bit bitwise logical AND of first ARF source register-pair with the\nbitwise negated value of a second ARF source register-pair.\n"),
        ("uget", "* `uget $aDst0, zimm8`\n\nRead the value of a control/status register into a general purpose\nregister. See control_and_status_registers.\n"),
        ("f32sigm", "* `f32sigm $aDst0, $aSrc0`\n\n\n"),
        ("$sp", "The stack pointer (an alias for `$m7`). This register is commonly used to hold the address of the bottom of the stack.\n"),
        ("cms", "* `cms $mDst0, $mSrc0`\n\nEstablishes the number of higher order bits that match the sign-bit (bit\n31). Result is always in the range \\[0..31\\].\n"),
        ("sort4x16hi", "* `sort4x16hi $mDst0, $mSrc0, $mSrc1`\n* `sort4x16hi $aDst0, $aSrc0, $aSrc1`\n* `sort4x16hi $aDst0, $aSrc0:BL, $aSrc1`\n\nPerform SIMD *sort* permutation on 4 x 16-bit values, across 2 source\nregisters, producing a 2 x 16-bit result.\n"),
        ("ldd16b16", "* `ldd16b16 $aDst0, $mAddr0++, $mBase0, $mDelta0@`\n\nPost-incrementing 16-bit delta load with simultaneous broadcast 16-bit\ndata load.\n\nDestination register-file: Combination of MRF and ARF\n\nEffective addresses:\n\n:   1.  A full-pointer value (`$m` register)\n    2.  Base address (`$m` register) plus 16-bit, unsigned address delta\n        (`$m` register)\n\nData format:\n\n:   1.  A 16-bit value (new delta-offset) written to the MRF delta\n        register.\n    2.  A 32-bit value formed via a broadcast operation on the 16-bit\n        loaded data value written to the ARF destination register.\n\nAddress auto-increment:\n\n:   1.  The full-pointer source register value is incremented by 2\n        (bytes).\n"),
        ("$TAS", "**T**he **a**xpy **s**cale(s) (or **T**emporary **a**mp **s**torage).\nThe scalar value(s) used by the various \\*axp(b)y and \\*raxb\ninstructions (`f32v2axpy`, `f16v4mix` for example), (or temporary\nstorage for `f32sisoamp`, `f32sisoslic`,f16v8topk-instr-defn\nandf32v4topk-instr-defn)\n\n## Note\n\nThe value of this register is *undefined* at worker launch\n"),
        ("f16v2exp2", "* `f16v2exp2 $aDst0, $aSrc0`\n\n\n"),
        ("f32v2absadd", "* `f32v2absadd $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Single-precision* 2-element vector element-wise addition of absolute\nvalues.\n"),
        ("$PRNG_0_1", "The most significant 32-bits of \\$PRNG_0.\n\n## Note\n\nThe value of this register is retained between worker exit and launch.\n"),
        ("brpos", "* `brpos $mSrc0, zimm19`\n\nConditional branch to absolute address. Branch taken if and only if\nregister value **is positive**. Immediate provides word-addressed\nabsolute destination address.\n"),
        ("f32toi32", "* `f32toi32 $aDst0, $aSrc0`\n\nConvert a *single-precision* floating-point value to a signed integer,\nrounding as per `$FP_CTL.RND`.\n"),
        ("not", "* `not $aDst0, $aSrc0`\n\nCompute the bitwise logical NOT of a single 32-bit ARF register.\n"),
        ("f16v4sisoamp", "* `f16v4sisoamp $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1, enumFlags`\n\n*f16* floating-point accumulating matrix-vector product. Input and\nresult partial-sums are 2 x *single-precision* values.\n\n::: tabularcolumns\np{dimexpr 0.07linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}p{dimexpr 0.05linewidth-2tabcolsep}\n\n::: rst-class\nfullwidth\n\n  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  \\$aSrc0\\|1     \\$AACC\\[14\\]            \\$AACC\\[12\\]            \\$AACC\\[10\\]            \\$AACC\\[8\\]             \\$AACC\\[6\\]             \\$AACC\\[4\\]             \\$AACC\\[2\\]             \\$AACC\\[0\\]             \\$aDst0\n  -------------- ----------------------- ----------------------- ----------------------- ----------------------- ----------------------- ----------------------- ----------------------- ----------------------- ---------\n  0[^1]\\|P0,P1   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**\n\n  0\\|P2,P3       **-**                   **-**                   **-**                   \\[**WARM-UP**           **PERIOD**\\]            **-**                   **-**                   **-**                   **-**\n\n  0\\|P4,P5       **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**\n\n  0\\| P6,P7      **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**                   **-**\n\n  x0\\|P8,P9      R7=x0.**CW**7,0+P7      R6=x0.**CW**6,0+P6      R5=x0.**CW**5,0+P5      R4=x0.**CW**4,0+P4      R3=x0.**CW**3,0+P3      R2=x0.**CW**2,0+P2      R1=x0.**CW**1,0+P1      R0=x0.**CW**0,0+P0      **-**\n\n  x1\\|P10,P11    R7+=x1.**CW**7,1        R6+=x1.**CW**6,1        R5+=x1.**CW**5,1        R4+=x1.**CW**4,1        R3+=x1.**CW**3,1        R2+=x1.**CW**2,1        R1+=x1.**CW**1,1        R0+=x1.**CW**0,1        **-**\n\n  x2\\|P12,P13    R7+=x2.**CW**7,2        R6+=x2.**CW**6,2        R5+=x2.**CW**5,2        R4+=x2.**CW**4,2        R3+=x2.**CW**3,2        R2+=x2.**CW**2,2        R1+=x2.**CW**1,2        R0+=x2.**CW**0,2        **-**\n\n  x3\\|P14,P15    R7+=x3.**CW**7,3        R6+=x3.**CW**6,3        R5+=x3.**CW**5,3        R4+=x3.**CW**4,3        R3+=x3.**CW**3,3        R2+=x3.**CW**2,3        R1+=x3.**CW**1,3        R0+=x3.**CW**0,3        **-**\n\n  x4\\|P16,P17    R15=x4.**CW**7,0+P15    R14=x4.**CW**6,0+P14    R13=x4.**CW**5,0+P13    R12=x4.**CW**4,0+P12    R11=x4.**CW**3,0+P11    R10=x4.**CW**2,0+P10    R9=x4.**CW**1,0+P9      R8=x4.**CW**0,0+P8      R0,R1\n\n  x5\\|P18,P19    R15+=x5.**CW**7,1       R14+=x5.**CW**6,1       R13+=x5.**CW**5,1       R12+=x5.**CW**4,1       R11+=x5.**CW**3,1       R10+=x5.**CW**2,1       R9+=x5.**CW**1,1        R8+=x5.**CW**0,1        R2,R3\n\n  x6\\|P20,P21    R15+=x6.**CW**7,2       R14+=x6.**CW**6,2       R13+=x6.**CW**5,2       R12+=x6.**CW**4,2       R11+=x6.**CW**3,2       R10+=x6.**CW**2,2       R9+=x6.**CW**1,2        R8+=x6.**CW**0,2        R4,R5\n\n  x7\\|P22,P23    R15+=x7.**CW**7,3       R14+=x7.**CW**6,3       R13+=x7.**CW**5,3       R12+=x7.**CW**4,3       R11+=x7.**CW**3,3       R10+=x7.**CW**2,3       R9+=x7.**CW**1,3        R8+=x7.**CW**0,3        R6,R7\n\n  x8\\|P24,P25    R23=x8.**CW**7,0+P23    R22=x8.**CW**6,0+P22    R21=x8.**CW**5,0+P21    R20=x8.**CW**4,0+P20    R19=x8.**CW**3,0+P19    R18=x8.**CW**2,0+P18    R17=x8.**CW**1,0+P17    R16=x8.**CW**0,0+P16    R8,R9\n\n  x9\\|P26,P27    R23+=x9.**CW**7,1       R22+=x9.**CW**6,1       R21+=x9.**CW**5,1       R20+=x9.**CW**4,1       R19+=x9.**CW**3,1       R18+=x9.**CW**2,1       R17+=x9.**CW**1,1       R16+=x9.**CW**0,1       R10,R11\n\n  x10\\|P28,P29   R23+=x10.**CW**7,2      R22+=x10.**CW**6,2      R21+=x10.**CW**5,2      R20+=x10.**CW**4,2      R19+=x10.**CW**3,2      R18+=x10.**CW**2,2      R17+=x10.**CW**1,2      R16+=x10.**CW**0,2      R12,R13\n\n  x11\\|P30,P31   R23+=x11.**CW**7,3      R22+=x11.**CW**6,3      R21+=x11.**CW**5,3      R20+=x11.**CW**4,3      R19+=x11.**CW**3,3      R18+=x11.**CW**2,3      R17+=x11.**CW**1,3      R16+=x11.**CW**0,3      R14,R15\n\n  x12\\|P32,P33   R31=x12.**CW**7,0+P31   R30=x12.**CW**6,0+P30   R29=x12.**CW**5,0+P29   R28=x12.**CW**4,0+P28   R27=x12.**CW**3,0+P27   R26=x12.**CW**2,0+P26   R25=x12.**CW**1,0+P25   R24=x12.**CW**0,0+P24   R16,R17\n  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n  : f16v4sisoamp 8x1x1x16 example sequence\n\nPn is *single-precision* input partial-sum *n* xn is an *f16v4* input\nvector **CW**m,n is the common weight state **\\$CWEI**\\_*m*\\_*n* Rn is\nthe final *single-precision* result of successive dot-product\naccumulations that began with Pn\n\nenumFlags format:\n\n![f16v4sisoamp immediate\nformat](images/autogen/F16AMP_ENUMFLAGS.*){.align-center}\n\n8 output channels are processed/produced.\n\n[^1]: 0 input used to fill AMP pipeline during warm-up period\n"),
        ("f32add", "* `f32add $aDst0, $aSrc0, $aSrc1`\n\n*Single-precision* addition of two register source values.\n"),
        ("lds8", "* `lds8 $mDst0, $mBase0, $mDelta0, $mOff0`\n* `lds8 $mDst0, $mBase0, $mDelta0, zimm12`\n\nLoad and sign-extend a single, 8-bit quantity fromTile Memory.\n\nDestination register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n\nData format:\n\n:   -   Result is a 32-bit value formed by sign-extending the 8-bit\n        loaded data value.\n"),
        ("zero", "Zero the register. Alias for `or $mDest, $mzero, 0`, `or $aDest, $azero, 0` or `or64 $aDest:1, $azeros, 0`.\n"),
        ("f32v2aop", "* `f32v2aop $aSrc0:Src0+1, $aSrc1:Src1+1, enumFlags`\n\n*Single-precision* 2-element vector outer product with accumulation to\n*single-precision*.\n"),
        ("$WSR", "Worker context status register.\n\n## Note\n\nThe value of this register is retained between worker termination via\nexit and launch via run.\n"),
        ("f32v2gina", "* `f32v2gina $aDst0:Dst0+1, $aSrc0:Src0+1, zimm12`\n\nGet and initialise accumulators.\n\n-   Read a pair of internal accumulator values as *single-precision*\n    values.\n>\n-   Write 2-element vector of *single-precision* input values to\n    internal accumulator state.\n>\n-   The instruction immediate specifies which pair of accumulator\n    registers are to be read and written:\n>\n    > a.  Read **\\$AACC**\\[0\\] and **\\$AACC**\\[2\\], write\n    >     **\\$AACC**\\[12\\] and **\\$AACC**\\[14\\]\n    > b.  Read **\\$AACC**\\[1\\] and **\\$AACC**\\[3\\], write\n    >     **\\$AACC**\\[13\\] and **\\$AACC**\\[15\\]\n    >\n    > and if and only if the platform supports 2 AMP sets:\n    >\n    > c.  Read **\\$AACC**\\[16\\] and **\\$AACC**\\[18\\], write\n    >     **\\$AACC**\\[28\\] and **\\$AACC**\\[30\\]\n    > d.  Read **\\$AACC**\\[17\\] and **\\$AACC**\\[19\\], write\n    >     **\\$AACC**\\[29\\] and **\\$AACC**\\[31\\]\n>\n-   Propagate internal accumulator state such that all accumulator\n    registers may be read and written via a sequence of this\n    instruction.\n\nzimm12 immediate format:\n\n![f32v2gina immediate\nformat](images/autogen/GINA_IMMFLAGS.*){.align-center}\n"),
        ("$m10", "`$m10` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("f32toui32", "* `f32toui32 $aDst0, $aSrc0`\n\nConvert a *single-precision* floating-point value to a unsigned integer,\nrounding as per `$FP_CTL.RND`.\n"),
        ("$a0:1", "`$a0` and `$a1` together as a 64-bit general purpose arithmetic register.\n"),
        ("f16v8absacc", "* `f16v8absacc $aSrc0:Src0+3`\n\n*Half-precision* 8-element vector accumulation of absolute values to\n*single-precision*.\n"),
        ("$a0", "`$a0` general purpose arithmetic register.\n"),
        ("bitrev8", "* `bitrev8 $mDst0, $mSrc0`\n\nReverse the bit order of each bit inside each byte of a register.\n"),
        ("f16v2tanh", "* `f16v2tanh $aDst0, $aSrc0`\n\n\n"),
        ("f16v8acc", "* `f16v8acc $aSrc0:Src0+3`\n\n*Half-precision* 8-element vector accumulation to *single-precision*.\n"),
        ("f16v2maxc", "* `f16v2maxc $aDst0, $aSrc0`\n\n*Half-precision* 2-element vector lateral maximum.\n"),
        ("$m8", "`$m8` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("f16v4sihoslic", "* `f16v4sihoslic $aDst0, $aSrc0:Src0+1, $aSrc1:Src1+1, enumFlags`\n\n*Half-precision* floating-point vector slim convolution. Input\npartial-sums are *single-precision*. Results are *half-precision*\n"),
        ("f32v4sqacc", "* `f32v4sqacc $aSrc0:Src0+3`\n\n*Single-precision* 4-element vector accumulation of squares to\n*single-precision*.\n"),
        ("f32min", "* `f32min $aDst0, $aSrc0, $aSrc1`\n\nDetermine the minimum floating-point value from two register source\nvalues.\n"),
        ("run", "* `run $mEntry0, $mVBase0, zimm16`\n\nLaunch a worker *thread*.\n\nAllocate execution time and *context* state to the *thread* whose entry\npoint is given by the register operand \\$mEntry0, using the vertex\naddress calculated by summing:\n\n1.  the register operand \\$mVBase0\n2.  the 16-bit immediate offset zimm16 × 4\n3.  the constant TMEM_REGION0_BASE_ADDR\n\n(i.e. the address formed by adding the register value \\$mVBase0 to the\nscaled immediate offset zimm16 is relative to TMEM_REGION0_BASE_ADDR)\n\n*Exception event*s will be raised for any of the following conditions:\n\n-   \\$mEntry0 is not 4-byte aligned\n-   \\$mVBase0 is not 4-byte aligned\n-   \\$mEntry0 is not a valid, executable address\n"),
        ("f32absadd", "* `f32absadd $aDst0, $aSrc0, $aSrc1`\n\nScalar *single-precision* addition of two absolute register source\nvalues.\n"),
        ("f16v4cmpeq", "* `f16v4cmpeq $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4cmpeq $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4cmpeq $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector equality test\n"),
        ("f16v4absacc", "* `f16v4absacc $aSrc0:Src0+1`\n\n*Half-precision* 4-element vector accumulation of absolute values to\n*single-precision*.\n"),
        ("f16v2cmpne", "* `f16v2cmpne $aDst0, $aSrc0, $aSrc1`\n* `f16v2cmpne $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2cmpne $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* floating-point vector equality test\n"),
        ("f32cmpeq", "* `f32cmpeq $aDst0, $aSrc0, $aSrc1`\n\nTest if two floating-point numbers are equal. If so, the destination\nregister is set to , otherwise it is set to .\n"),
        ("f16v8sqacc", "* `f16v8sqacc $aSrc0:Src0+3`\n\n*Half-precision* 8-element vector accumulation of squares to\n*single-precision*.\n"),
        ("andc", "* `andc $mDst0, $mSrc0, $mSrc1`\n* `andc $mDst0, $mSrc0, zimm12`\n* `andc $aDst0, $aSrc0, $aSrc1`\n* `andc $aDst0, $aSrc0, zimm12`\n* `andc $aDst0, $aSrc0, immz12`\n\nBitwise logical AND of first source register value with the bitwise\nnegated value of a second source register value or *zero extended*/*zero\ntailed* immediate.\n"),
        ("$azero", "Alias for `$a15`. This register is read-only and always returns 0.\n"),
        ("f32tanh", "* `f32tanh $aDst0, $aSrc0`\n\n*Single-precision* floating-point hyperbolic tangent.\n"),
        ("f16v2sigm", "* `f16v2sigm $aDst0, $aSrc0`\n\n\n"),
        ("f16v4absadd", "* `f16v4absadd $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector element-wise addition of absolute\nvalues.\n"),
        ("f16v4cmplt", "* `f16v4cmplt $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4cmplt $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4cmplt $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector less-than test\n"),
        ("$a5", "`$a5` general purpose arithmetic register.\n"),
        ("f16v4clamp", "* `f16v4clamp $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1`\n\n*Half-precision* floating-point vector min-of-maximum\n"),
        ("brneg", "* `brneg $mSrc0, zimm19`\n\nConditional branch to absolute address. Branch taken if and only if\nregister value **is negative**. Immediate provides word-addressed\nabsolute destination address.\n"),
        ("f16v2cmpgt", "* `f16v2cmpgt $aDst0, $aSrc0, $aSrc1`\n* `f16v2cmpgt $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2cmpgt $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* floating-point vector greater-than test\n"),
        ("ldconst", "Load a constant into a register. This can be used to load 32-bit constants which takes two actual instructions. This compiles to `setzi` instructions.\n"),
        ("f16v2add", "* `f16v2add $aDst0, $aSrc0, $aSrc1`\n* `f16v2add $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2add $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* floating-point vector add on two register source\nvalues.\n"),
        ("$m11", "`$m11` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("st64", "* `st64 $aSrc0:Src0+1, $mBase0, $mDelta0, $mOffset0`\n* `st64 $aSrc0:Src0+1, $mBase0, $mDelta0, zimm12`\n\nStore a single 64-bit value, from a naturally aligned register pair\ntoTile Memory.\n\nSource register-file: ARF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n"),
        ("$m9", "`$m9` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("f16v2mul", "* `f16v2mul $aDst0, $aSrc0, $aSrc1`\n* `f16v2mul $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2mul $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* 2-element vector, Hadamard product\n"),
        ("$lr", "Alias for `$m6`. Link Register. This register is commonly used to hold the return address of a function.\n"),
        ("$m2", "`$m2` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("exitpos", "* `exitpos $mSrc0`\n\nTerminate current execution of a *Worker* thread and return a Boolean\nexit status to the *Supervisor* thread. This instruction passes control\nfrom a *Worker* thread to the *Supervisor* thread. The currently\nallocated thread execution slot is returned to the *Supervisor*, which\nmay reassign the execution slot to another task.\n"),
        ("f16v2cmac", "* `f16v2cmac $aSrc0, $aSrc1`\n\n*Half-precision* floating-point vector element-wise multiply with\n*single-precision* lateral sum and accumulate.\n"),
        ("uput", "* `uput zimm8, $aSrc0`\n\nWrite to a control register in the upper CSR address space. See\nWorker-csrs\n"),
        ("swap8", "* `swap8 $mDst0, $mSrc0`\n\nPerform *swap* SIMD permutation on 4 x 8-bit values.\n"),
        ("cmpult", "* `cmpult $mDst0, $mSrc0, $mSrc1`\n* `cmpult $mDst0, $mSrc0, zimm16`\n\n*Less than* comparison of two **unsigned** source values. Destination\nregister is set to 1 if the first source operand value is less than the\nsecond. Otherwise the destination register is set to 0. to 0. The\ncomparison operation is **unsigned**.\n"),
        ("$REPEAT_END", "The address of the very next instruction following the current (previous\nif not currently executing a repeat block) `rpt` repeat-body.\n\n## Note\n\nThe value of this register is *undefined* at worker launch\n"),
        ("ld2x64pace", "* `ld2x64pace $aDst0:Dst0+1, $aDst1:Dst1+1, $mAddr0:Addr0+1+=, $mStride0, Strimm2x2`\n\nNaturally aligned dual 64-bit load, with dual independent\npost-incrementing addresses.\n\nDestination register-file: ARF only\n\nEffective addresses:\n\n:   -   2 independent load addresses\n    -   provided directly from MRF as a register pair\n    -   lower register provides 1st load address\n    -   upper register provides 2nd load address\n\nData format:\n\n:   -   Results are 2 unmodified 64-bit values stored in 2 naturally\n        aligned register pairs.\n\nNote that a TEXCPT_INVALID_OP exception will occur if the two\ndestination register pairs are not distinct.\n"),
        ("f32v2cmple", "* `f32v2cmple $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2cmple $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector less-than or equal-to test\n"),
        ("$m15", "`$m15` register. Read only. Always reads 0. Also available through the `$mzero` alias.\n"),
        ("f16v4stacc", "* `f16v4stacc $aDst0:Dst0+1, enumFlags`\n\nSort/shuffle (permute) through accumulators.\n\n-   Perform \\$AACC state propagation as specified by the immediate.\n-   The destination register pair is written with 64-bits of result\n    data from a combination of \\$AACC registers. The precise\n    combination is specified by the immediate.\n"),
        ("f16v2cmple", "* `f16v2cmple $aDst0, $aSrc0, $aSrc1`\n* `f16v2cmple $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2cmple $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* floating-point vector less-than test\n"),
        ("f32v2mul", "* `f32v2mul $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2mul $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point 2 element vector, Hadamard product\n"),
        ("ldd16a64", "* `ldd16a64 $aDst0:Dst0+1, $mAddr0++, $mBase0, $mDelta0@`\n\nPost-incrementing 16-bit delta load with simultaneous 64-bit data load.\n\nDestination register-file: Combination of MRF and ARF\n\nEffective addresses:\n\n:   1.  A full-pointer value (`$m` register)\n    2.  Base address (`$m` register) plus 16-bit, unsigned address delta\n        (`$m` register)\n\nData format:\n\n:   1.  A 16-bit value (new delta-offset) written to the MRF delta\n        register.\n    2.  A 64-bit value written to the ARF destination register pair.\n\nAddress auto-increment:\n\n:   1.  The full-pointer source register value is incremented by 2\n        (bytes).\n"),
        ("$REPEAT_COUNT", "The number of repetitions of a `rpt` repeat-body remaining. Note that\nany *exception* detected when `$REPEAT_COUNT` is non-zero will be\ntreated as malign (including Debug exceptions).\n\n## Note\n\nThe value of this register is retained between worker exit and launch.\n\n::: spec\nrepeat_count_width_0xf91c7131e8ca1572\n\n`$REPEAT_COUNT.VALUE` register field is 16 bits wide.\n"),
        ("st64step", "* `st64step $aSrc0:Src0+1, $mBase0, $mDelta0+=, simm8`\n* `st64step $aSrc0:Src0+1, $mBase0, $mDelta0+=, $mStride0`\n\nNaturally aligned 64-bit store with scaled post-incrementing address.\n\nSource register-file: ARF only (a naturally aligned register-pair)\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register\n        (after the value has been scaled to atom size).\n"),
        ("ld64step", "* `ld64step $aDst0:Dst0+1, $mBase0, $mDelta0+=, simm8`\n* `ld64step $aDst0:Dst0+1, $mBase0, $mDelta0+=, $mStride0`\n\nNaturally aligned 64-bit load with scaled post-incrementing address.\n\nDestination register-file: ARF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nData format:\n\n:   -   Result is an unmodified 64-bit value stored in a naturally\n        aligned register-pair.\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register\n        (after the value has been scaled to atom size).\n"),
        ("f16v2absadd", "* `f16v2absadd $aDst0, $aSrc0, $aSrc1`\n\n*Half-precision* 2-element vector element-wise addition of absolute\nvalues.\n"),
        ("f16v2cmpeq", "* `f16v2cmpeq $aDst0, $aSrc0, $aSrc1`\n* `f16v2cmpeq $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2cmpeq $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* 2-element vector equality test\n"),
        ("f32sisoamp", "* `f32sisoamp $aDst0:Dst0+1, $aSrc0, $aSrc1:Src1+1, enumFlags`\n\n*Single-precision* floating-point **a**ccumulating **m**atrix-vector\n**p**roduct. Input partial-sums and result values are\n*single-precision*.\n\nenumFlags format:\n\n![f32sisoamp immediate\nformat](images/autogen/F32AMP_ENUMFLAGS.*){.align-center}\n\n8 output channels are processed/produced.\n"),
        ("$a14", "`$a14` register. Always reads 0. Also available through the `$azero` or `$azeros` (64-bit) alias.\n"),
        ("trap", "* `trap zimm4`\n\nUnconditionally raise a *patched breakpoint* *exception event*.\n"),
        ("$m14", "`$m14` register. Read only. Returns an implementation-specific value.\n"),
        ("$DBG_DATA", "CSR alias. See `$DBG_DATA`. Note that a write from a `put` wins over a\nsimultaneous write via this alias.\n"),
        ("f32cmpne", "* `f32cmpne $aDst0, $aSrc0, $aSrc1`\n\nTest if a floating-point number is not equal to second floating-point\nnumber. If so, the destination register is set to , otherwise it is set\nto .\n"),
        ("f32v4absacc", "* `f32v4absacc $aSrc0:Src0+3`\n\n*Single-precision* 4-element vector accumulation of absolute values to\n*single-precision*.\n"),
        ("ld64b16pace", "* `ld64b16pace $aDst0:Dst0+1, $aDst1, $mAddr0:Addr0+1+=, $mStride0, Strimm2x2`\n\nNaturally aligned 64-bit and broadcast 16-bit load, with dual\nindependent post-incrementing addresses.\n\nDestination register-file: ARF only\n\nEffective addresses:\n\n:   -   2 independent full load addresses\n    -   provided directly from MRF as a register pair\n    -   lower register provides 1st load address\n    -   upper register provides 2nd load address\n\nData format:\n\n:   -   Results are:\n        -   1 unmodified 64-bit value stored in a naturally aligned\n            register pair\n        -   1 16-bit value broadcast (duplicated) into a single ARF\n            register\n\nNote that a TEXCPT_INVALID_OP exception will occur if the two\ndestination register pairs are not distinct.\n"),
        ("tapack", "* `tapack $mDst0:Dst0+1, $mAddr0, $mAddr1, $mAddr2`\n\nConvert 3 absolute addresses to the triple-packed address format.\n"),
        ("$PRNG_0_0", "The least significant 32-bits of \\$PRNG_0.\n\n## Note\n\nThe value of this register is retained between worker exit and launch.\n"),
        ("$a4:5", "`$a4` and `$a5` together as a 64-bit general purpose arithmetic register.\n"),
        ("f32cmplt", "* `f32cmplt $aDst0, $aSrc0, $aSrc1`\n\nTest if a floating-point number is less than a second floating-point\nnumber. If so, the destination register is set to , otherwise it is set\nto .\n"),
        ("f32oox", "* `f32oox $aDst0, $aSrc0`\n\n*Single-precision* reciprocal.\n"),
        ("f16v4cmpge", "* `f16v4cmpge $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4cmpge $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4cmpge $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector greater-than or equal-to test\n"),
        ("cmpslt", "* `cmpslt $mDst0, $mSrc0, $mSrc1`\n* `cmpslt $mDst0, $mSrc0, simm16`\n\n*Less than* comparison of two **signed** source values. Destination\nregister is set to 1 if the first source operand is less than the\nsecond. Otherwise the destination register is set to 0. The comparison\noperation is **signed**.\n"),
        ("f32v2clamp", "* `f32v2clamp $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector min-of-maximum\n"),
        ("f32v2mac", "* `f32v2mac $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector multiply and 32-bit accumulate\n"),
        ("bri", "* `bri zimm19`\n\nUnconditional branch to absolute address. Immediate provides\nword-addressed absolute destination address.\n"),
        ("$m3", "`$m3` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("ldst64pace", "* `ldst64pace $aDst0:Dst0+1, $aSrc0:Src0+1, $mAddr0:Addr0+1+=, $mStride0, Strimm2x2`\n\nNaturally aligned 64-bit load and simultaneous 64-bit store, with dual\nindependent post-incrementing addresses.\n\nDestination register-file: ARF only\n\nSource register-file: ARF only\n\nEffective addresses:\n\n:   -   independent load and store addresses\n    -   provided directly from MRF as a register pair\n    -   lower register provides load address\n    -   store address is split across the upper-bits of both registers\n        (see `tapack`)\n\nData format:\n\n:   -   Load result is an unmodified 64-bit value stored in a naturally\n        aligned register pair.\n"),
        ("f16v4add", "* `f16v4add $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4add $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4add $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector element-wise addition.\n"),
        ("f32absmax", "* `f32absmax $aDst0, $aSrc0, $aSrc1`\n\nDetermine the maximum floating-point value from two absolute register\nsource values.\n"),
        ("sort4x32hi", "* `sort4x32hi $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\nPerform SIMD *sort* permutation on 4 x 32-bit values, across 2 source\nregister-pairs, producing a 2 x 32-bit result.\n"),
        ("min", "* `min $mDst0, $mSrc0, $mSrc1`\n* `min $mDst0, $mSrc0, zimm16`\n* `min $mDst0, $mSrc0, simm16`\n\nSelect the minimum of 2 signed integer values. Immediates may be *sign\nextended*, *zero extended* or *zero tailed*.\n"),
        ("ldz16", "* `ldz16 $mDst0, $mBase0, $mDelta0, $mOff0`\n* `ldz16 $mDst0, $mBase0, $mDelta0, zimm12`\n\nLoad and zero-extend a single, naturally aligned 16-bit quantity\nfromTile Memory.\n\nDestination register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n\nData format:\n\n:   -   Result is a 32-bit value formed by zero-extending the 16-bit\n        data value.\n"),
        ("f16v4sub", "* `f16v4sub $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4sub $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4sub $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* floating-point 4-element vector subtraction\n"),
        ("f32v2cmplt", "* `f32v2cmplt $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2cmplt $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector less-than test\n"),
        ("f16v4cmac", "* `f16v4cmac $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Half-precision* floating-point vector element-wise multiply with\n*single-precision* 2x2 lateral sum and accumulate.\n"),
        ("f32v4tof16", "* `f32v4tof16 $aDst0:Dst0+1, $aSrc0:Src0+3`\n\n*Single-precision* floating-point 4-element vector to *f16* 4-element\nvector conversion.\n"),
        ("$a4", "`$a4` general purpose arithmetic register.\n"),
        ("roll8l", "* `roll8l $mDst0, $mSrc0, $mSrc1`\n\nPerform a SIMD *roll-left* permutation on the 8 x 8-bit values across 2\nsource registers.\n"),
        ("ld64putcs", "* `ld64putcs zimm8`\n\nLoad a naturally-aligned 64-bit quantity and write the value to the\ncommon compute configuration space. The load address is provided by\n`$CCCSLOAD`, which is automatically post-incremented by 8.\n"),
        ("f16v4sum", "* `f16v4sum $aDst0:Dst0+1, $aSrc0:Src0+1`\n\n*Half-precision* 4-element vector 2x2 lateral summation to 2-element\n*single-precision* vector.\n"),
        ("f32exp", "* `f32exp $aDst0, $aSrc0`\n\n\n"),
        ("f16v2log2", "* `f16v2log2 $aDst0, $aSrc0`\n\n\n"),
        ("fnop", "Do nothing for one cycle (aux pipeline). Alias for `or $azero, $azero, 0`\n"),
        ("ldd16a32", "* `ldd16a32 $aDst0, $mAddr0++, $mBase0, $mDelta0@`\n\nPost-incrementing 16-bit delta load with simultaneous 32-bit data load.\n\nDestination register-file: Combination of MRF and ARF\n\nEffective addresses:\n\n:   1.  A full-pointer value (`$m` register)\n    2.  Base address (`$m` register) plus 16-bit, unsigned address delta\n        (`$m` register)\n\nData format:\n\n:   1.  A 16-bit value (new delta-offset) written to the MRF delta\n        register.\n    2.  A 32-bit value written to the ARF destination register.\n\nAddress auto-increment:\n\n:   1.  The full-pointer source register value is incremented by 2\n        (bytes).\n"),
        ("f16v4rmask", "* `f16v4rmask $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1`\n\n*Half-precision* floating-point vector random mask.\n\nThe result is a masked version of the input vector, with each element of\nthe input being individually masked with the probability specified by\nthe bottom 17-bits of the 2nd input operand:\n\n-   if \\$aSrc1\\[16\\] == 1, no masking is applied (the result is a copy\n    of the input vector)\n-   else if \\$aSrc1\\[16:0\\] == 0, the result is a zero vector\n-   otherwise each element is individually unmasked with probability\n    \\$frac{\\$aSrc1\\[15:0\\]}{65536}\\$\n\nPRNG is used by this instruction to generate 4 x 16-bit random values\nfrom the discrete uniform distribution.\n"),
        ("stm32", "* `stm32 $mSrc0, $mBase0, $mOffset0`\n\nStore a single 32-bit MRF register value toTile Memory.\n\nSource register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned scaled offset (`$m` register)\n"),
        ("$FP_CTL", "Floating-point control register.\n\n## Note\n\nThe initial value of this register on worker launch is provided by .\n"),
        ("f32v2cmpeq", "* `f32v2cmpeq $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2cmpeq $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector equality test\n"),
        ("$COUNT_L", "[Tile]{.title-ref} cycle counter value. Lower 32-bits\n"),
        ("exitnz", "* `exitnz $mSrc0`\n\nTerminate current execution of a *Worker* thread and return a Boolean\nexit status to the *Supervisor* thread. This instruction passes control\nfrom a *Worker* thread to the *Supervisor* thread. The currently\nallocated thread execution slot is returned to the *Supervisor*, which\nmay reassign the execution slot to another task.\n\n## Note\n\nThis instruction considers the floating-point *single-precision* value\n-0.0 to not be zero (+0.0)\n"),
        ("$m12", "`$m12` Worker Base Register. Returns the worker context scratch space base address. Also available through the alias `$worker_base`.\n"),
        ("sort4x32lo", "* `sort4x32lo $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\nPerform SIMD *sort* permutation on 4 x 32-bit values, across 2 source\nregister-pairs, producing a 2 x 32-bit result.\n"),
        ("f32tof16", "* `f32tof16 $aDst0, $aSrc0`\n\nConvert a *single-precision* value to *f16*, using the rounding mode as\nspecified by `$FP_CTL.RND`/`$FP_CTL.ESR`. Supports stochastic rounding.\nSee fp_format_conversions.\n\nThe 16-bit result of the conversion is broadcast to (duplicated into) a\nsingle ARF register, producing a 2-element vector of identical *f16*\nvalues.\n"),
        ("$a1", "`$a1` general purpose arithmetic register.\n"),
        ("brz", "* `brz $mSrc0, zimm19`\n\nConditional branch to absolute address. Branch taken if and only if\nregister value **is 0**. Immediate provides word-addressed absolute\ndestination address.\n\n## Note\n\nThis instruction considers the floating-point *single-precision* value\n-0.0 to not be zero (+0.0)\n"),
        ("nop", "Do nothing for one cycle (main pipeline). Alias for `or $mzero, $mzero, 0`\n"),
        ("and64", "* `and64 $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n64-bit bitwise logical AND of two ARF source register-pairs.\n"),
        ("st32step", "* `st32step $mSrc0, $mBase0, $mDelta0+=, simm8`\n* `st32step $aSrc0, $mBase0, $mDelta0+=, simm8`\n* `st32step $aSrc0, $mBase0, $mDelta0+=, $mStride0`\n\nNaturally aligned 32-bit store with scaled post-incrementing address.\n\nSource register-file: MRF or ARF\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register\n        (after the value has been scaled to atom size).\n"),
        ("clz", "* `clz $mDst0, $mSrc0`\n\nEstablishes the number of higher order bits that are zero. An unsigned\ninterpretation of the source value can be stored in (32 - result) bits\nwithout loss.\n"),
        ("f16v4absmax", "* `f16v4absmax $aDst0:Dst0+1, $aSrc1:Src1+1, $aSrc0:Src0+1`\n\n*Half-precision* 4-element vector element-wise max of absolute values\n"),
        ("get", "* `get $mDst0, zimm8`\n\nRead the value of a control/status register into a general purpose\nregister. See control_and_status_registers.\n"),
        ("$a6:7", "`$a6` and `$a7` together as a 64-bit general purpose arithmetic register.\n"),
        ("$mzero", "Alias for `$m15`. This register is read-only and always returns 0.\n"),
        ("$a2:3", "`$a2` and `$a3` together as a 64-bit general purpose arithmetic register.\n"),
        ("urand32", "* `urand32 $aDst0`\n\nUniform distribution, 32-bit random integer.\n"),
        ("ldb16b16", "* `ldb16b16 $aDst0:Dst0+1, $mBase0, $mDelta0++, $mMiniD0&gt;&gt;`\n\nBroadcast 16-bit load from base + 16-bit delta-offset with 2nd broadcast\n16-bit load from base plus 2nd 16-bit delta-offset.\n\nDestination register-file: ARF only\n\nEffective addresses:\n\n:   -   2 load addresses provided directly from MRF as a common base\n        register plus independent 16-bit delta-offsets (packed into a\n        single MRF register)\n\nData format:\n\n:   -   Results are 2 x *f16v2* values stored in a naturally aligned\n        register pair. Each *f16v2* vector is created from a broadcast\n        operation on a single 16-bit value loaded from *Tile Memory*.\n\nAddress auto-increment:\n\n:   -   The two 16-bit delta-offsets are post-incremented independently:\n        -   One is incremented by 2 (bytes)\n        -   The other is incremented according to the 4-bit mini-delta\n            value in the lsbs of the 4th operand.\n    -   The mini-delta operand is also right-shifted by 4.\n"),
        ("f32max", "* `f32max $aDst0, $aSrc0, $aSrc1`\n\nDetermine the maximum floating-point value from two register source\nvalues.\n"),
        ("$m7", "`$m7` is used as the stack pointer. Also available through `$sp`.\n"),
        ("f32fromui32", "* `f32fromui32 $aDst0, $aSrc0`\n\nConvert an unsigned integer to a *single-precision* floating-point\nvalue.\n"),
        ("f16v4sisoslic", "* `f16v4sisoslic $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1, enumFlags`\n\n*f16* floating-point slim convolution. Input and result partial-sums are\n2 x *single-precision* values.\n\n::: tabularcolumns\np{dimexpr 0.07linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}p{dimexpr 0.05linewidth-2tabcolsep}\n\n::: rst-class\nfullwidth\n\n  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  \\$aSrc0\\|1    \\$AACC\\[14\\]   \\$AACC\\[10\\]           \\$AACC\\[6\\]         \\$AACC\\[2\\]        \\$AACC\\[12\\]   \\$AACC\\[8\\]            \\$AACC\\[4\\]         \\$AACC\\[0\\]        \\$aDst0\n  ------------- -------------- ---------------------- ------------------- ------------------ -------------- ---------------------- ------------------- ------------------ ---------\n  x0\\|P0,P1     **-**          R1=x0.**CW**5,0+P1     **-**               **-**              **-**          R0=x0.**CW**4,0+P0     **-**               **-**              **-**\n\n  x1\\|P2,P3     **-**          R3=x1.**CW**5,0+P3     R1+=x1.**CW**3,0    **-**              **-**          R2=x1.**CW**4,0+P2     R0+=x1.**CW**2,0    **-**              **-**\n\n  x2\\|P4,P5     **-**          R5=x2.**CW**5,0+P5     R3+=x2.**CW**3,0    R1+=x2.**CW**1,0   **-**          R4=x2.**CW**4,0+P4     R2+=x2.**CW**2,0    R0+=x2.**CW**0,0   **-**\n\n  x3\\|P6,P7     **-**          R7=x3.**CW**5,0+P7     R5+=x3.**CW**3,0    R3+=x3.**CW**1,0   **-**          R6=x3.**CW**4,0+P6     R4+=x3.**CW**2,0    R2+=x3.**CW**0,0   R0,R1\n\n  x4\\|P8,P9     **-**          R9=x4.**CW**5,0+P9     R7+=x4.**CW**3,0    R5+=x4.**CW**1,0   **-**          R8=x4.**CW**4,0+P8     R6+=x4.**CW**2,0    R4+=x4.**CW**0,0   R2,R3\n\n  x5\\|P10,P11   **-**          R11=x5.**CW**5,0+P11   R9+=x5.**CW**3,0    R7+=x5.**CW**1,0   **-**          R10=x5.**CW**4,0+P10   R8+=x5.**CW**2,0    R6+=x5.**CW**0,0   R4,R5\n\n  x6\\|P12,P13   **-**          R13=x6.**CW**5,0+P13   R11+=x6.**CW**3,0   R9+=x6.**CW**1,0   **-**          R12=x6.**CW**4,0+P12   R10+=x6.**CW**2,0   R8+=x6.**CW**0,0   R6,R7\n  ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n  : f16v4sisoslic, 2x1x3x4 example sequence\n\n::: tabularcolumns\np{dimexpr 0.07linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}p{dimexpr 0.05linewidth-2tabcolsep}\n\n::: rst-class\nfullwidth\n\n  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  \\$aSrc0\\|1    \\$AACC\\[14\\]           \\$AACC\\[10\\]        \\$AACC\\[6\\]        \\$AACC\\[2\\]        \\$AACC\\[12\\]           \\$AACC\\[8\\]         \\$AACC\\[4\\]        \\$AACC\\[0\\]        \\$aDst0\n  ------------- ---------------------- ------------------- ------------------ ------------------ ---------------------- ------------------- ------------------ ------------------ ---------\n  x0\\|P0,P1     R1=x0.**CW**7,0+P1     **-**               **-**              **-**              R0=x0.**CW**6,0+P0     **-**               **-**              **-**              **-**\n\n  x1\\|P2,P3     R3=x1.**CW**7,0+P3     R1+=x1.**CW**5,0    **-**              **-**              R2=x1.**CW**6,0+P2     R0+=x1.**CW**4,0    **-**              **-**              **-**\n\n  x2\\|P4,P5     R5=x2.**CW**7,0+P5     R3+=x2.**CW**5,0    R1+=x2.**CW**3,0   **-**              R4=x2.**CW**6,0+P4     R2+=x2.**CW**4,0    R0+=x2.**CW**2,0   **-**              **-**\n\n  x3\\|P6,P7     R7=x3.**CW**7,0+P7     R5+=x3.**CW**5,0    R3+=x3.**CW**3,0   R1+=x3.**CW**1,0   R6=x3.**CW**6,0+P6     R4+=x3.**CW**4,0    R2+=x3.**CW**2,0   R0+=x3.**CW**0,0   **-**\n\n  x4\\|P8,P9     R9=x4.**CW**7,0+P9     R7+=x4.**CW**5,0    R5+=x4.**CW**3,0   R3+=x4.**CW**1,0   R8=x4.**CW**6,0+P8     R6+=x4.**CW**4,0    R4+=x4.**CW**2,0   R2+=x4.**CW**0,0   R0,R1\n\n  x5\\|P10,P11   R11=x5.**CW**7,0+P11   R9+=x5.**CW**5,0    R7+=x5.**CW**3,0   R5+=x5.**CW**1,0   R10=x5.**CW**6,0+P10   R8+=x5.**CW**4,0    R6+=x5.**CW**2,0   R4+=x5.**CW**0,0   R2,R3\n\n  x6\\|P12,P13   R13=x6.**CW**7,0+P13   R11+=x6.**CW**5,0   R9+=x6.**CW**3,0   R7+=x6.**CW**1,0   R12=x6.**CW**6,0+P12   R10+=x6.**CW**4,0   R8+=x6.**CW**2,0   R6+=x6.**CW**0,0   R4,R5\n  -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n  : f16v4sisoslic, 2x1x4x4 example sequence\n\nPn is *single-precision* input partial-sum *n* xn is an *f16v4* input\nvector **CW**m,n is the common weight state **\\$CWEI**\\_*m*\\_*n* Rn is\nthe final *single-precision* result of successive dot-product\naccumulations that began with Pn\n\nenumFlags format:\n\n![f16v4sisoslic immediate\nformat](images/autogen/F16SLIC_ENUMFLAGS.*){.align-center}\n"),
        ("shr", "* `shr $mDst0, $mSrc0, $mSrc1`\n* `shr $mDst0, $mSrc0, zimm12`\n\nPerform a logical right shift, of up-to 31-bits, on a register value.\n"),
        ("$REPEAT_FIRST", "The address of the initial *Execution Bundle* of the current (previous\nif not currently executing a repeat block) `rpt` repeat-body.\n\n## Note\n\nThe value of this register is *undefined* at worker launch\n"),
        ("mov", "Copy the value in `$mSrc` to `mDst`. This compiles to `or` or `atom` instructions.\n"),
        ("f32v2max", "* `f32v2max $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector element-wise max\n"),
        ("f16v4acc", "* `f16v4acc $aSrc0:Src0+1`\n\n*Half-precision* 4-element vector accumulation to *single-precision*.\n"),
        ("sort8x8hi", "* `sort8x8hi $mDst0, $mSrc0, $mSrc1`\n\nPerform SIMD *sort* permutation on 8 x 8-bit values, across 2 source\nregisters, returning the upper *word* of the result. See [sort8x8lo]()\nfor lower *word*.\n"),
        ("ld2xst64pace", "* `ld2xst64pace $aDst0:Dst0+3, $aSrc0:Src0+1, $mAddr0:Addr0+1+=, $mStride0, Strimm3x2`\n\nNaturally aligned dual 64-bit load and simultaneous 64-bit store, with 3\nindependent post-incrementing addresses.\n\nDestination register-file: ARF only\n\nSource register-file: ARF only\n\nEffective addresses:\n\n:   -   3 independent addresses provided directly from MRF, packed into\n        a register pair\n\nData format:\n\n:   -   Load results are 2 unmodified 64-bit values stored in a\n        naturally aligned register quad.\n"),
        ("f32log2", "* `f32log2 $aDst0, $aSrc0`\n\n\n"),
        ("f32v2axpy", "* `f32v2axpy $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Single-precision* 2-element vector **z** = *a***x** + **y** The scalar\nmultiplicand *a* is provided by the internal state element `$TAS`.\n\nResults are stored within the accumulator state. Destination registers\nare written with the previous accumulator state.\n"),
        ("ldb16step", "* `ldb16step $aDst0, $mBase0, $mDelta0+=, simm8`\n* `ldb16step $aDst0, $mBase0, $mDelta0+=, $mStride0`\n\nNaturally aligned 16-bit load and broadcast with scaled\npost-incrementing address.\n\nDestination register-file: ARF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nData format:\n\n:   -   Result is a 32-bit value formed by broadcasting (duplicating)\n        the 16-bit data value.\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register\n        (after the value has been scaled to atom size).\n"),
        ("roll16", "* `roll16 $mDst0, $mSrc0, $mSrc1`\n* `roll16 $aDst0, $aSrc0, $aSrc1`\n\nPerform a SIMD *roll* permutation on the 4 x 16-bit values across 2\nsource registers. Equivalent to a SIMD *roll* operation on 8 x 8-bit\nvalues.\n"),
        ("atom", "* `atom $mDst0, $aSrc0`\n\nCopy an ARF register value to MRF. No format conversion is performed.\n"),
        ("sub", "* `sub $mDst0, $mSrc1, $mSrc0`\n* `sub $mDst0, zimm16, $mSrc0`\n* `sub $mDst0, simm16, $mSrc0`\n\nInteger subtraction of 1 register value from another or from immediate.\nImmediates may be *sign extended*, *zero extended* or *zero tailed* to\n*word* width.\n"),
        ("f32v2rmask", "* `f32v2rmask $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1`\n\n*Single-precision* floating-point vector random mask.\n\nThe result is a masked version of the input vector, with each element of\nthe input being individually masked with the probability specified by\nthe bottom 17-bits of the 2nd input operand:\n\n-   if \\$aSrc1\\[16\\] == 1, no masking is applied (the result is a copy\n    of the input vector)\n-   else if \\$aSrc1\\[16:0\\] == 0, the result is a zero vector\n-   otherwise each element is individually unmasked with probability\n    \\$frac{\\$aSrc1\\[15:0\\]}{65536}\\$\n\nPRNG is used by this instruction to generate 2 x 16-bit random values\nfrom the discrete uniform distribution.\n"),
        ("ldz8", "* `ldz8 $mDst0, $mBase0, $mDelta0, $mOff0`\n* `ldz8 $mDst0, $mBase0, $mDelta0, zimm12`\n\nLoad and zero-extend a single, 8-bit quantity fromTile Memory.\n\nDestination register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n\nData format:\n\n:   -   Result is a 32-bit value formed by zero-extending the 8-bit\n        loaded data value.\n"),
        ("f32class", "* `f32class $aDst0, $aSrc0`\n\n*Single-precision* floating-point number classifier. IEEE 754-2008:\n5.7.2\n"),
        ("ld64", "* `ld64 $aDst0:Dst0+1, $mBase0, $mDelta0, $mOff0`\n* `ld64 $aDst0:Dst0+1, $mBase0, $mDelta0, zimm12`\n\nLoad a single, naturally aligned 64-bit quantity fromTile Memory.\n\nDestination register-file: ARF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n\nData format:\n\n:   -   Result is an unmodified 64-bit value stored in a naturally\n        aligned register-pair.\n"),
        ("f32v2sub", "* `f32v2sub $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2sub $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector subtraction\n"),
        ("f16v2clamp", "* `f16v2clamp $aDst0, $aSrc0, $aSrc1`\n\n*Half-precision* floating-point vector min-of-maximum\n"),
        ("f32sisoslic", "* `f32sisoslic $aDst0:Dst0+1, $aSrc0, $aSrc1:Src1+1, enumFlags`\n\n*Single-precision* floating-point **sli**m **c**onvolution. Input\npartial-sums are *single-precision*. Results are *single-precision*.\n\n::: tabularcolumns\np{dimexpr 0.07linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}\\>{centering}p{dimexpr\n0.11linewidth-2tabcolsep}p{dimexpr 0.05linewidth-2tabcolsep}\n\n::: rst-class\nfullwidth\n\n  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n  \\$aSrc0\\|1     \\$AACC\\[14\\]   \\$AACC\\[10\\]             \\$AACC\\[6\\]          \\$AACC\\[2\\]          \\$AACC\\[12\\]   \\$AACC\\[8\\]              \\$AACC\\[4\\]          \\$AACC\\[0\\]          \\$aDst0\n  -------------- -------------- ------------------------ -------------------- -------------------- -------------- ------------------------ -------------------- -------------------- ---------\n  x0L\\|P0,P1     **-**          R1=x0L×**CW**5,0L+P1     **-**                **-**                **-**          R0=x0L×**CW**4,0L+P0     **-**                **-**                **-**\n\n  x0U\\|D0,D1     **-**          R1+=x0U×**CW**5,0U       **-**                **-**                **-**          R0+=x0U×**CW**4,0U       **-**                **-**                **-**\n\n  x1L\\|P2,P3     **-**          R3=x1L×**CW**5,0L+P3     R1+=x1L×**CW**3,0L   **-**                **-**          R2=x1L×**CW**4,0L+P2     R0+=x1L×**CW**2,0L   **-**                **-**\n\n  x1U\\|D2,D3     **-**          R3+=x1U×**CW**5,0U       R1+=x1U×**CW**3,0U   **-**                **-**          R2+=x1U×**CW**4,0U       R0+=x1U×**CW**2,0U   **-**                **-**\n\n  x2L\\|P4,P5     **-**          R5=x2L×**CW**5,0L+P5     R3+=x2L×**CW**3,0L   R1+=x2L×**CW**1,0L   **-**          R4=x2L×**CW**4,0L+P4     R2+=x2L×**CW**2,0L   R0+=x2L×**CW**0,0L   **-**\n\n  x2U\\|D4,D5     **-**          R5+=x2U×**CW**5,0U       R3+=x2U×**CW**3,0U   R1+=x2U×**CW**1,0U   **-**          R4+=x2U×**CW**4,0U       R2+=x2U×**CW**2,0U   R0+=x2U×**CW**0,0U   **-**\n\n  x3L\\|P6,P7     **-**          R7=x3L×**CW**5,0L+P7     R5+=x3L×**CW**3,0L   R3+=x3L×**CW**1,0L   **-**          R6=x3L×**CW**4,0L+P6     R4+=x3L×**CW**2,0L   R2+=x3L×**CW**0,0L   R0,R1\n\n  x3U\\|D6,D7     **-**          R7+=x3U×**CW**5,0U       R5+=x3U×**CW**3,0U   R3+=x3U×**CW**1,0U   **-**          R6+=x3U×**CW**4,0U       R4+=x3U×**CW**2,0U   R2+=x3U×**CW**0,0U   **-**\n\n  x4L\\|P8,P9     **-**          R9=x4L×**CW**5,0L+P9     R7+=x4L×**CW**3,0L   R5+=x4L×**CW**1,0L   **-**          R8=x4L×**CW**4,0L+P8     R6+=x4L×**CW**2,0L   R4+=x4L×**CW**0,0L   R2,R3\n\n  x4U\\|D8,D9     **-**          R9+=x4U×**CW**5,0U       R7+=x4U×**CW**3,0U   R5+=x4U×**CW**1,0U   **-**          R8+=x4U×**CW**4,0U       R6+=x4U×**CW**2,0U   R4+=x4U×**CW**0,0U   **-**\n\n  x5L\\|P10,P11   **-**          R11=x5L×**CW**5,0L+P11   R9+=x5L×**CW**3,0L   R7+=x5L×**CW**1,0L   **-**          R10=x5L×**CW**4,0L+P10   R8+=x5L×**CW**2,0L   R6+=x5L×**CW**0,0L   R4,R5\n\n  x5U\\|D10,D11   **-**          R11+=x5U×**CW**5,0U      R9+=x5U×**CW**3,0U   R7+=x5U×**CW**1,0U   **-**          R10+=x5U×**CW**4,0U      R8+=x5U×**CW**2,0U   R6+=x5U×**CW**0,0U   **-**\n  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n  : f32sisoslic, 2x1x3x2 example sequence\n\nPn is *single-precision* input partial-sum *n* Dn is 0 under normal\ncircumstances (`$a14:15`) xnL is the 1st element (element 0) of a\n*f32v2* input vector xnU is the 2nd element (element 1) of a *f32v2*\ninput vector **CW**m,nL is the least significant 32-bits of common\nweight state **\\$CWEI**\\_*m*\\_*n* **CW**m,nU is the most significant\n32-bits of common weight state **\\$CWEI**\\_*m*\\_*n* Rn is the final\n*single-precision* result of successive multiply-accumulations that\nbegan with Pn\n\nenumFlags format:\n\n![f32sisoslic immediate\nformat](images/autogen/F32SLIC_ENUMFLAGS.*){.align-center}\n\n2 output channels are processed/produced.\n"),
        ("f16v2max", "* `f16v2max $aDst0, $aSrc0, $aSrc1`\n\n*Half-precision* floating-point vector max\n"),
        ("ld64a32pace", "* `ld64a32pace $aDst0:Dst0+1, $aDst1, $mAddr0:Addr0+1+=, $mStride0, Strimm2x2`\n\nNaturally aligned dual 64/32-bit load, with dual independent\npost-incrementing addresses.\n\nDestination register-file: ARF only\n\nEffective addresses:\n\n:   -   2 independent load addresses\n    -   provided directly from MRF as a register pair\n    -   lower register provides 1st load address\n    -   upper register provides 2nd load address\n\nData format:\n\n:   -   Results are:\n        -   1 unmodified 64-bit value stored in a naturally aligned\n            register pair\n        -   1 unmodified 32-bit value stored in a single ARF register\n\nNote that a TEXCPT_INVALID_OP exception will occur if the two\ndestination register pairs are not distinct.\n"),
        ("f16v4istacc", "* `f16v4istacc $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1, enumFlags`\n\nSort/shuffle (permute) through accumulators, with new input.\n\n-   Present 128-bits of register operand source data to be\n    sorted/shuffled (other otherwise permuted) using the \\$AACC state.\n    The precise behaviour is dependent on the value of the immediate.\n-   Perform \\$AACC state propagation as specified by the immediate.\n-   The destination register pair is written with 64-bits of result\n    data from a combination of \\$AACC registers. The precise\n    combination is specified by the immediate.\n"),
        ("shuf8x8lo", "* `shuf8x8lo $mDst0, $mSrc0, $mSrc1`\n\nPerform SIMD *shuffle* permutation on 8 x 8-bit values, across 2 source\nregisters, returning the lower *word* of the result. See [shuf8x8hi]()\nfor upper *word*.\n"),
        ("f16v2ln", "* `f16v2ln $aDst0, $aSrc0`\n\n\n"),
        ("ldz16step", "* `ldz16step $mDst0, $mBase0, $mDelta0+=, simm8`\n* `ldz16step $mDst0, $mBase0, $mDelta0+=, $mStride0`\n\nZero-extending, naturally aligned 16-bit load with scaled\npost-incrementing address.\n\nDestination register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nData format:\n\n:   -   Result is a 32-bit value formed by zero-extending the 16-bit\n        data value.\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register\n        (after the value has been scaled to atom size).\n"),
        ("f32v2grand", "* `f32v2grand $aDst0:Dst0+1`\n\nGaussian distribution, 2-element *single-precision* random vector\n"),
        ("f16v2class", "* `f16v2class $aDst0, $aSrc0`\n\n*Half-precision* floating-point vector classifier. IEEE 754-2008: 5.7.2\n"),
        ("brnzdec", "* `brnzdec $mSrcDst0, zimm19`\n\nConditional branch to absolute address with counter decrement. Branch\ntaken and counter value decremented by 1 if and only if counter register\nvalue **is not 0**. Immediate provides word-addressed absolute\ndestination address.\n\n## Note\n\nThis instruction considers the floating-point *single-precision* value\n-0.0 to not be equal to zero (+0.0)\n"),
        ("ld32", "* `ld32 $mDst0, $mBase0, $mDelta0, $mOff0`\n* `ld32 $aDst0, $mBase0, $mDelta0, $mOff0`\n* `ld32 $mDst0, $mBase0, $mDelta0, zimm12`\n* `ld32 $aDst0, $mBase0, $mDelta0, zimm12`\n\nLoad a single, naturally aligned 32-bit value fromTile Memory.\n\nDestination register-file: MRF or ARF\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n\nData format:\n\n:   -   Result is an unmodified 32-bit value.\n"),
        ("f16v4maxc", "* `f16v4maxc $aDst0, $aSrc0:Src0+1`\n\n*Half-precision* 4-element vector 2x2 lateral maximum.\n"),
        ("$m6", "`$m6` memory register, generally used for storing addresses, offsets, etc.\n"),
        ("f32sufromui", "* `f32sufromui $aDst0, $aSrc0`\n\nSymmetric, unbiased conversion from an unsigned 32-bit integer to\n*single-precision* floating-point.\n\nThe *single-precision* result lies within the range \\$\\[-frac{1}{2},\nfrac{1}{2}\\]\\$ but can never be exactly 0. The result will also have a\nmagnitude of at least \\$frac{1}{2\\^{33}}\\$ (and therefore results will\nnever be inside the denormalised number range for *single-precision*).\n\nNote that this instruction can be combined with `urand32`/`urand64` to\nproduce a random, uniformly distributed floating-point value.\n"),
        ("f16v4cmpgt", "* `f16v4cmpgt $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4cmpgt $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4cmpgt $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector greater-than test\n"),
        ("$FP_CLR", "Floating-point exception/state clear. Write 0b1 to clear the specified\nfloating-point exception flag or internal state. Reads always return 0.\n"),
        ("st64pace", "* `st64pace $aSrc0:Src0+1, $mAddr0:Addr0+1+=, $mStride0, Strimm2`\n\nNaturally aligned 64-bit store with scaled post-incrementing address.\n\nSource register-file: ARF only (a naturally aligned register-pair)\n\nEffective address:\n\n:   -   Absolute address 2 from a triple packed address register pair\n"),
        ("$FP_STS", "Floating-point status register.\n\n## Note\n\nThis register is explicitly reset on worker launch\n"),
        ("max", "* `max $mDst0, $mSrc0, $mSrc1`\n* `max $mDst0, $mSrc0, zimm16`\n* `max $mDst0, $mSrc0, simm16`\n\nSelect the maximum of 1 signed register source value and 1 signed\nregister or *sign extended*/*zero extended*/*zero tailed* immediate\nvalue.\n"),
        ("ld128step", "* `ld128step $aDst0:Dst0+3, $mBase0, $mDelta0+=, simm8`\n* `ld128step $aDst0:Dst0+3, $mBase0, $mDelta0+=, $mStride0`\n\nNaturally aligned 128-bit load from interleaved memory region with\nscaled post-incrementing address.\n\nDestination register-file: ARF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n\nData format:\n\n:   -   Result is an unmodified 128-bit value stored in a naturally\n        aligned register-quad.\n\nAddress auto-increment:\n\n:   -   The unsigned address delta MRF register operand is\n        post-incremented by the signed immediate or stride register\n        (after the value has been scaled to atom size).\n"),
        ("abs", "* `abs $mDst0, $mSrc0`\n\nAbsolute value of signed 32-bit integer.\n"),
        ("ldb16", "* `ldb16 $aDst0, $mBase0, $mDelta0, $mOff0`\n* `ldb16 $aDst0, $mBase0, $mDelta0, zimm12`\n\nLoad and broadcast a single, naturally aligned 16-bit quantity fromTile\nMemory.\n\nDestination register-file: ARF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n\nData format:\n\n:   -   Result is a 32-bit value formed by broadcasting (duplicating)\n        the 16-bit data value.\n"),
        ("roll8r", "* `roll8r $mDst0, $mSrc0, $mSrc1`\n\nPerform a SIMD *roll-right* permutation on the 8 x 8-bit values across 2\nsource registers.\n"),
        ("f32v2cmpne", "* `f32v2cmpne $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2cmpne $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector inequality test\n"),
        ("ld128", "* `ld128 $aDst0:Dst0+3, $mBase0, $mDelta0, $mOff0`\n* `ld128 $aDst0:Dst0+3, $mBase0, $mDelta0, zimm12`\n\nLoad a single, naturally aligned 128-bit quantity from an interleaved\nregion ofTile Memory.\n\nDestination register-file: ARF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n\nData format:\n\n:   -   Result is an unmodified 128-bit value stored in a naturally\n        aligned register-quad.\n"),
        ("or64", "* `or64 $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\nCompute the bitwise logical OR of 1 ARF register-pair source value with\na 2nd ARF register-pair.\n"),
        ("f16v4max", "* `f16v4max $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector element-wise max\n"),
        ("and", "* `and $mDst0, $mSrc0, $mSrc1`\n* `and $mDst0, $mSrc0, zimm12`\n* `and $aDst0, $aSrc0, $aSrc1`\n* `and $aDst0, $aSrc0, zimm12`\n* `and $aDst0, $aSrc0, immz12`\n\nBitwise logical AND of two source register values, or 1 source register\nand 1 *zero extended*/*zero tailed* immediate.\n"),
        ("f32v2add", "* `f32v2add $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2add $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector add\n"),
        ("f16v2cmpge", "* `f16v2cmpge $aDst0, $aSrc0, $aSrc1`\n* `f16v2cmpge $aDst0, $aSrc0:BL, $aSrc1`\n* `f16v2cmpge $aDst0, $aSrc0:BU, $aSrc1`\n\n*Half-precision* floating-point vector greater-than-or-equal-to test\n"),
        ("$mworker_base", "The Worker Base Register (an alias for `$m12`). Returns the worker context scratch space base address.\n"),
        ("setzi", "* `setzi $mDst0, zimm20`\n* `setzi $aDst0, zimm20`\n\nSet register to *zero extended* 20-bit immediate value.\n"),
        ("runall", "* `runall $mEntry0, $mVBase0, zimm16`\n\nAllocate execution time and context state to a batch of worker\n*thread*s:\n\n-   The total number of *thread*s launched is equal to the number of\n    hardware *worker* contexts ()\n>\n-   All *thread*s use the same entry point (\\$mEntry0)\n>\n-   The value of `$VERTEX_BASE` assigned to the first allocated\n    *worker* is provided by the register \\$mVBase0\n>\n-   The value of `$VERTEX_BASE` assigned to every other *worker* is:\n>\n    > -   \\$mVBase0 + (*n* × zimm16 × 4) (\\$n in {\\[1, CTXT_WORKERS -\n    >     1\\]}\\$)\n\n*Exception event*s will be raised for any of the following conditions:\n\n-   \\$mEntry0 is not 4-byte aligned\n-   \\$mVBase0 is not 4-byte aligned\n-   \\$mEntry0 is not a valid, executable address\n-   There are any active Worker contexts\n\nIf there are active Worker contexts, `$SSR.RAERR` will also be set to\n0b1 and all active Workers will raise a exception during the retirement\nof their next instruction.\n"),
        ("f32cmple", "* `f32cmple $aDst0, $aSrc0, $aSrc1`\n\nTest if a floating-point number is less than or equal to a second\nfloating-point number. If so, the destination register is set to ,\notherwise it is set to .\n"),
        ("cmpne", "* `cmpne $mDst0, $mSrc0, $mSrc1`\n\n*Inequality* comparison of two source values. The destination is set to\n0 if the two source operands are equal. Otherwise the destination\nregister is set to 1.\n"),
        ("$DBG_BRK_ID", "Id of BRK channel which caused the last BREAK *exception event*. See\ndebug_model.\n\n## Note\n\nFor Worker contexts, the value of this register is retained between\nworker exit and launch.\n"),
        ("$FP_ICTL", "Floating point control register initial value. The *worker*\nfloating-point control register `$FP_CTL` is initialised with the\ncontents of this register prior to worker activation.\n\nSee `run` and `runall`\n"),
        ("$a3", "`$a3` general purpose arithmetic register.\n"),
        ("$a6", "`$a6` general purpose arithmetic register.\n"),
        ("f32v2cmpge", "* `f32v2cmpge $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f32v2cmpge $aDst0:Dst0+1, $aSrc0:B, $aSrc1:Src1+1`\n\n*Single-precision* floating-point vector greater-than or equal-to test\n"),
        ("f16v4cmpne", "* `f16v4cmpne $aDst0:Dst0+1, $aSrc0:Src0+1, $aSrc1:Src1+1`\n* `f16v4cmpne $aDst0:Dst0+1, $aSrc0:BL, $aSrc1:Src1+1`\n* `f16v4cmpne $aDst0:Dst0+1, $aSrc0:BU, $aSrc1:Src1+1`\n\n*Half-precision* 4-element vector inequality test\n"),
        ("lds16", "* `lds16 $mDst0, $mBase0, $mDelta0, $mOff0`\n* `lds16 $mDst0, $mBase0, $mDelta0, zimm12`\n\nLoad and sign-extend a single, naturally aligned 16-bit quantity\nfromTile Memory.\n\nDestination register-file: MRF only\n\nEffective address formed from:\n\n:   -   Base address (`$m` register)\n    -   Unsigned address delta (`$m` register)\n    -   Unsigned scaled offset (`$m` register or immediate)\n\nData format:\n\n:   -   Result is a 32-bit value formed by sign-extending the 16-bit\n        data value.\n"),
    ],
};

pub struct CompletionDef<'a> {
    pub label: &'a str,
    pub detail: &'a str,
    pub documentation: &'a str,
}

pub const COMPLETIONS: &[CompletionDef] = &[
  CompletionDef { label: "$CCCSLOAD", detail: "$CCCSLOAD", documentation: "Post-incrementing load address for `ld64putcs` and `ld128putcs`.\n" },
  CompletionDef { label: "$COUNT_L", detail: "$COUNT_L", documentation: "[Tile]{.title-ref} cycle counter value. Lower 32-bits\n" },
  CompletionDef { label: "$COUNT_U", detail: "$COUNT_U", documentation: "[Tile]{.title-ref} cycle counter value. Upper 32-bits\n" },
  CompletionDef { label: "$CTXT_STS", detail: "$CTXT_STS", documentation: "CSR alias. This register can be read to ascertain the execution status\nof all Tile contexts.\n" },
  CompletionDef { label: "$DBG_BRK_ID", detail: "$DBG_BRK_ID", documentation: "Id of BRK channel which caused the last BREAK *exception event*. See\ndebug_model.\n" },
  CompletionDef { label: "$DBG_DATA", detail: "$DBG_DATA", documentation: "CSR alias. This register can be configured (via `$DBG_ECSR`) to behave\nin two different ways:\n\n1.  A general purpose 32-bit data register for passing data into and\n    out ofTile via the debug bus.\n2.  To present the current value of `$PC` for any context.\n" },
  CompletionDef { label: "$FP_CLR", detail: "$FP_CLR", documentation: "Floating-point exception/state clear.\n" },
  CompletionDef { label: "$FP_CTL", detail: "$FP_CTL", documentation: "Floating-point control register.\n" },
  CompletionDef { label: "$FP_ICTL", detail: "$FP_ICTL", documentation: "Floating-point control register initial value.\n" },
  CompletionDef { label: "$FP_STS", detail: "$FP_STS", documentation: "Floating-point status register.\n" },
  CompletionDef { label: "$PC", detail: "$PC", documentation: "Context Program Counter.\n" },
  CompletionDef { label: "$PRNG_0_0", detail: "$PRNG_0_0", documentation: "The least significant 32-bits of \\$PRNG_0.\n" },
  CompletionDef { label: "$PRNG_0_1", detail: "$PRNG_0_1", documentation: "The most significant 32-bits of \\$PRNG_0.\n" },
  CompletionDef { label: "$PRNG_1_0", detail: "$PRNG_1_0", documentation: "The least significant 32-bits of \\$PRNG_1.\n" },
  CompletionDef { label: "$PRNG_1_1", detail: "$PRNG_1_1", documentation: "The most significant 32-bits of \\$PRNG_1.\n" },
  CompletionDef { label: "$PRNG_SEED", detail: "$PRNG_SEED", documentation: "32-bit Pseudo-random-number-generator initialisation.\n" },
  CompletionDef { label: "$REPEAT_COUNT", detail: "$REPEAT_COUNT", documentation: "`rpt` loop down-counter.\n" },
  CompletionDef { label: "$REPEAT_END", detail: "$REPEAT_END", documentation: "`rpt` loop end address.\n" },
  CompletionDef { label: "$REPEAT_FIRST", detail: "$REPEAT_FIRST", documentation: "`rpt` loop start address.\n" },
  CompletionDef { label: "$TAS", detail: "$TAS", documentation: "**T**he **a**xpy **s**cale (or **T**emporary **a**mp **s**torage).\n" },
  CompletionDef { label: "$VERTEX_BASE", detail: "$VERTEX_BASE", documentation: "Vertex data structure pointer.\n" },
  CompletionDef { label: "$WORKER_BASE", detail: "$WORKER_BASE", documentation: "Worker context scratch space base address.\n" },
  CompletionDef { label: "$WSR", detail: "$WSR", documentation: "Worker context status register.\n" },
  CompletionDef { label: "$a0", detail: "$a0", documentation: "`$a0` general purpose arithmetic register.\n" },
  CompletionDef { label: "$a0:1", detail: "$a0:1", documentation: "`$a0` and `$a1` together as a 64-bit general purpose arithmetic register.\n" },
  CompletionDef { label: "$a1", detail: "$a1", documentation: "`$a1` general purpose arithmetic register.\n" },
  CompletionDef { label: "$a14", detail: "$a14", documentation: "`$a14` register. Always reads 0. Also available through the `$azero` or `$azeros` (64-bit) alias.\n" },
  CompletionDef { label: "$a15", detail: "$a15", documentation: "`$a15` register. Always reads 0. You probably meant to use `$azero` or `$azeros`.\n" },
  CompletionDef { label: "$a2", detail: "$a2", documentation: "`$a2` general purpose arithmetic register.\n" },
  CompletionDef { label: "$a2:3", detail: "$a2:3", documentation: "`$a2` and `$a3` together as a 64-bit general purpose arithmetic register.\n" },
  CompletionDef { label: "$a3", detail: "$a3", documentation: "`$a3` general purpose arithmetic register.\n" },
  CompletionDef { label: "$a4", detail: "$a4", documentation: "`$a4` general purpose arithmetic register.\n" },
  CompletionDef { label: "$a4:5", detail: "$a4:5", documentation: "`$a4` and `$a5` together as a 64-bit general purpose arithmetic register.\n" },
  CompletionDef { label: "$a5", detail: "$a5", documentation: "`$a5` general purpose arithmetic register.\n" },
  CompletionDef { label: "$a6", detail: "$a6", documentation: "`$a6` general purpose arithmetic register.\n" },
  CompletionDef { label: "$a6:7", detail: "$a6:7", documentation: "`$a6` and `$a7` together as a 64-bit general purpose arithmetic register.\n" },
  CompletionDef { label: "$a7", detail: "$a7", documentation: "`$a7` general purpose arithmetic register.\n" },
  CompletionDef { label: "$azero", detail: "$azero", documentation: "Alias for `$a15`. This register is read-only and always returns 0.\n" },
  CompletionDef { label: "$azeros", detail: "$azeros", documentation: "Alias for `$a14:15`. This register is read-only and always returns 0.\n" },
  CompletionDef { label: "$fp", detail: "$fp", documentation: "Alias for `$m5`. Frame Pointer. Points to the part of the stack used by the current function.\n" },
  CompletionDef { label: "$lr", detail: "$lr", documentation: "Alias for `$m6`. Link Register. This register is commonly used to hold the return address of a function.\n" },
  CompletionDef { label: "$m0", detail: "$m0", documentation: "`$m0` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m1", detail: "$m1", documentation: "`$m1` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m10", detail: "$m10", documentation: "`$m10` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m11", detail: "$m11", documentation: "`$m11` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m12", detail: "$m12", documentation: "`$m12` Worker Base Register. Returns the worker context scratch space base address. Also available through the alias `$worker_base`.\n" },
  CompletionDef { label: "$m13", detail: "$m13", documentation: "`$m13` Vertex Base Register. Vertex data structure pointer. Initialised on behalf of a Worker context by the Supervisor via `run` or `runall`. This register can also be read through the `$vertex_base` alias.\n" },
  CompletionDef { label: "$m14", detail: "$m14", documentation: "`$m14` register. Read only. Returns an implementation-specific value.\n" },
  CompletionDef { label: "$m15", detail: "$m15", documentation: "`$m15` register. Read only. Always reads 0. Also available through the `$mzero` alias.\n" },
  CompletionDef { label: "$m2", detail: "$m2", documentation: "`$m2` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m3", detail: "$m3", documentation: "`$m3` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m4", detail: "$m4", documentation: "`$m4` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m5", detail: "$m5", documentation: "`$m5` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m6", detail: "$m6", documentation: "`$m6` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m7", detail: "$m7", documentation: "`$m7` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m8", detail: "$m8", documentation: "`$m8` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$m9", detail: "$m9", documentation: "`$m9` memory register, generally used for storing addresses, offsets, etc.\n" },
  CompletionDef { label: "$mvertex_base", detail: "$mvertex_base", documentation: "The Vertex Base Register (an alias for `$m13`). Initialised on behalf of a Worker context by the Supervisor via `run` or `runall`.\n" },
  CompletionDef { label: "$mworker_base", detail: "$mworker_base", documentation: "The Worker Base Register (an alias for `$m12`). Returns the worker context scratch space base address.\n" },
  CompletionDef { label: "$mzero", detail: "$mzero", documentation: "Alias for `$m15`. This register is read-only and always returns 0.\n" },
  CompletionDef { label: "$sp", detail: "$sp", documentation: "The stack pointer (an alias for `$m7`). This register is commonly used to hold the address of the bottom of the stack.\n" },
  CompletionDef { label: "abs", detail: "abs $mDst0 $mSrc0", documentation: "Absolute value of signed 32-bit integer\n" },
  CompletionDef { label: "add", detail: "add $mDst0 $mSrc0 $mSrc1 (and 2 more)", documentation: "Integer addition\n" },
  CompletionDef { label: "and", detail: "and $mDst0 $mSrc0 $mSrc1 (and 4 more)", documentation: "32-bit bitwise logical AND\n" },
  CompletionDef { label: "and64", detail: "and64 $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "64-bit bitwise logical AND\n" },
  CompletionDef { label: "andc", detail: "andc $mDst0 $mSrc0 $mSrc1 (and 4 more)", documentation: "32-bit bitwise logical AND Complement\n" },
  CompletionDef { label: "andc64", detail: "andc64 $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "64-bit bitwise logical AND Complement\n" },
  CompletionDef { label: "atom", detail: "atom $mDst0 $aSrc0", documentation: "Copy an *arf* register value to *mrf*\n" },
  CompletionDef { label: "bitrev8", detail: "bitrev8 $mDst0 $mSrc0", documentation: "Byte-wise bit order reversal\n" },
  CompletionDef { label: "br", detail: "br $mSrc0", documentation: "Unconditional absolute branch to register target\n" },
  CompletionDef { label: "bri", detail: "bri zimm19", documentation: "Unconditional absolute branch to immediate target\n" },
  CompletionDef { label: "brneg", detail: "brneg $mSrc0 zimm19", documentation: "Branch if negative\n" },
  CompletionDef { label: "brnz", detail: "brnz $mSrc0 zimm19", documentation: "Branch if not zero\n" },
  CompletionDef { label: "brnzdec", detail: "brnzdec $mSrcDst0 zimm19", documentation: "Branch if not zero, with counter decrement\n" },
  CompletionDef { label: "brpos", detail: "brpos $mSrc0 zimm19", documentation: "Branch if positive\n" },
  CompletionDef { label: "brz", detail: "brz $mSrc0 zimm19", documentation: "Branch if zero\n" },
  CompletionDef { label: "call", detail: "call $mDst0 zimm20", documentation: "Function call\n" },
  CompletionDef { label: "clz", detail: "clz $mDst0 $mSrc0", documentation: "Count leading zero bits\n" },
  CompletionDef { label: "cmpeq", detail: "cmpeq $mDst0 $mSrc0 $mSrc1 (and 2 more)", documentation: "Equality test\n" },
  CompletionDef { label: "cmpne", detail: "cmpne $mDst0 $mSrc0 $mSrc1", documentation: "Inequality test\n" },
  CompletionDef { label: "cmpslt", detail: "cmpslt $mDst0 $mSrc0 $mSrc1 (and 1 more)", documentation: "Signed less-than test\n" },
  CompletionDef { label: "cmpult", detail: "cmpult $mDst0 $mSrc0 $mSrc1 (and 1 more)", documentation: "Unsigned less-than test\n" },
  CompletionDef { label: "cms", detail: "cms $mDst0 $mSrc0", documentation: "Count matching sign bits\n" },
  CompletionDef { label: "exitneg", detail: "exitneg $mSrc0", documentation: "Worker thread termination\n" },
  CompletionDef { label: "exitnz", detail: "exitnz $mSrc0", documentation: "Worker thread termination\n" },
  CompletionDef { label: "exitpos", detail: "exitpos $mSrc0", documentation: "Worker thread termination\n" },
  CompletionDef { label: "exitz", detail: "exitz $mSrc0", documentation: "Worker thread termination\n" },
  CompletionDef { label: "f16tof32", detail: "f16tof32 $aDst0 $aSrc0", documentation: "*f16* to *single-precision*\n" },
  CompletionDef { label: "f16v2absadd", detail: "f16v2absadd $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector add of absolutes\n" },
  CompletionDef { label: "f16v2absmax", detail: "f16v2absmax $aDst0 $aSrc1 $aSrc0", documentation: "*Half-precision* floating-point vector max of absolutes\n" },
  CompletionDef { label: "f16v2add", detail: "f16v2add $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* floating-point vector add\n" },
  CompletionDef { label: "f16v2clamp", detail: "f16v2clamp $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector min-of-maximum\n" },
  CompletionDef { label: "f16v2class", detail: "f16v2class $aDst0 $aSrc0", documentation: "*Half-precision* floating-point vector classifier\n" },
  CompletionDef { label: "f16v2cmac", detail: "f16v2cmac $aSrc0 $aSrc1", documentation: "*Half-precision* vector multiply with lateral sum and accumulate\n" },
  CompletionDef { label: "f16v2cmpeq", detail: "f16v2cmpeq $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* vector equality test\n" },
  CompletionDef { label: "f16v2cmpge", detail: "f16v2cmpge $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* floating-point vector greater-than-or-equal-to test\n" },
  CompletionDef { label: "f16v2cmpgt", detail: "f16v2cmpgt $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* floating-point vector greater-than test\n" },
  CompletionDef { label: "f16v2cmple", detail: "f16v2cmple $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* floating-point vector less-than-or-equal-to test\n" },
  CompletionDef { label: "f16v2cmplt", detail: "f16v2cmplt $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* floating-point vector less-than test\n" },
  CompletionDef { label: "f16v2cmpne", detail: "f16v2cmpne $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* floating-point vector inequality test\n" },
  CompletionDef { label: "f16v2exp", detail: "f16v2exp $aDst0 $aSrc0", documentation: "Natural exponential\n" },
  CompletionDef { label: "f16v2exp2", detail: "f16v2exp2 $aDst0 $aSrc0", documentation: "Base 2 exponential\n" },
  CompletionDef { label: "f16v2gina", detail: "f16v2gina $aDst0 $aSrc0 zimm12", documentation: "Get and initialise accumulators\n" },
  CompletionDef { label: "f16v2grand", detail: "f16v2grand $aDst0", documentation: "Gaussian distribution, 2-element *half-precision* random vector\n" },
  CompletionDef { label: "f16v2ln", detail: "f16v2ln $aDst0 $aSrc0", documentation: "*Half-precision* floating-point vector natural logarithm\n" },
  CompletionDef { label: "f16v2log2", detail: "f16v2log2 $aDst0 $aSrc0", documentation: "*Half-precision* floating-point vector base 2 logarithm\n" },
  CompletionDef { label: "f16v2max", detail: "f16v2max $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector max\n" },
  CompletionDef { label: "f16v2maxc", detail: "f16v2maxc $aDst0 $aSrc0", documentation: "*Half-precision* vector lateral max\n" },
  CompletionDef { label: "f16v2min", detail: "f16v2min $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector element-wise minimum\n" },
  CompletionDef { label: "f16v2mul", detail: "f16v2mul $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* 2-element vector Hadamard product\n" },
  CompletionDef { label: "f16v2sigm", detail: "f16v2sigm $aDst0 $aSrc0", documentation: "*Half-precision* 2-element vector logistic\n" },
  CompletionDef { label: "f16v2sub", detail: "f16v2sub $aDst0 $aSrc0 $aSrc1 (and 2 more)", documentation: "*Half-precision* floating-point vector subtract\n" },
  CompletionDef { label: "f16v2sufromui", detail: "f16v2sufromui $aDst0 $aSrc0", documentation: "\n" },
  CompletionDef { label: "f16v2sum", detail: "f16v2sum $aDst0 $aSrc0", documentation: "*Half-precision* vector lateral summation\n" },
  CompletionDef { label: "f16v2tanh", detail: "f16v2tanh $aDst0 $aSrc0", documentation: "\n" },
  CompletionDef { label: "f16v2tof32", detail: "f16v2tof32 $aDst0:Dst0+1 $aSrc0", documentation: "*f16* pair to *single-precision* pair\n" },
  CompletionDef { label: "f16v4absacc", detail: "f16v4absacc $aSrc0:Src0+1", documentation: "*Half-precision* vector accumulation of absolutes\n" },
  CompletionDef { label: "f16v4absadd", detail: "f16v4absadd $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector addition of absolutes\n" },
  CompletionDef { label: "f16v4absmax", detail: "f16v4absmax $aDst0:Dst0+1 $aSrc1:Src1+1 $aSrc0:Src0+1", documentation: "*Half-precision* 4-element vector max of absolutes\n" },
  CompletionDef { label: "f16v4acc", detail: "f16v4acc $aSrc0:Src0+1", documentation: "*Half-precision* vector accumulate\n" },
  CompletionDef { label: "f16v4add", detail: "f16v4add $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* vector addition\n" },
  CompletionDef { label: "f16v4clamp", detail: "f16v4clamp $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1", documentation: "*Half-precision* floating-point vector min-of-maximum\n" },
  CompletionDef { label: "f16v4class", detail: "f16v4class $aDst0 $aSrc0:Src0+1", documentation: "*Half-precision* floating-point vector classifier\n" },
  CompletionDef { label: "f16v4cmac", detail: "f16v4cmac $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector multiply with 2x2 lateral sum and accumulate\n" },
  CompletionDef { label: "f16v4cmpeq", detail: "f16v4cmpeq $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* vector equality test\n" },
  CompletionDef { label: "f16v4cmpge", detail: "f16v4cmpge $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* vector greater-than or equal-to test\n" },
  CompletionDef { label: "f16v4cmpgt", detail: "f16v4cmpgt $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* vector greater-than test\n" },
  CompletionDef { label: "f16v4cmple", detail: "f16v4cmple $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* vector less-than or equal-to test\n" },
  CompletionDef { label: "f16v4cmplt", detail: "f16v4cmplt $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* vector less-than test\n" },
  CompletionDef { label: "f16v4cmpne", detail: "f16v4cmpne $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* vector inequality test\n" },
  CompletionDef { label: "f16v4gacc", detail: "f16v4gacc $aDst0:Dst0+1", documentation: "Get accumulators\n" },
  CompletionDef { label: "f16v4hihoamp", detail: "f16v4hihoamp $aDst0 $aSrc0:Src0+1 $aSrc1 enumFlags", documentation: "*Half-precision* vector accumulating matrix-vector product\n" },
  CompletionDef { label: "f16v4hihoslic", detail: "f16v4hihoslic $aDst0 $aSrc0:Src0+1 $aSrc1 enumFlags", documentation: "*Half-precision* slim convolution\n" },
  CompletionDef { label: "f16v4istacc", detail: "f16v4istacc $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "Sort/shuffle (permute) through accumulators, with new input\n" },
  CompletionDef { label: "f16v4max", detail: "f16v4max $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* 4-element vector max\n" },
  CompletionDef { label: "f16v4maxc", detail: "f16v4maxc $aDst0 $aSrc0:Src0+1", documentation: "*Half-precision* vector 2x2 lateral max\n" },
  CompletionDef { label: "f16v4min", detail: "f16v4min $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector minimum\n" },
  CompletionDef { label: "f16v4mix", detail: "f16v4mix $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* 4-element vector z = ax + y\n" },
  CompletionDef { label: "f16v4mul", detail: "f16v4mul $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* 4-element vector Hadamard product\n" },
  CompletionDef { label: "f16v4rmask", detail: "f16v4rmask $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1", documentation: "*Half-precision* vector random mask\n" },
  CompletionDef { label: "f16v4sihoamp", detail: "f16v4sihoamp $aDst0 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*Half-precision* floating-point vector accumulating matrix-vector\nproduct\n" },
  CompletionDef { label: "f16v4sihoslic", detail: "f16v4sihoslic $aDst0 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*Half-precision* floating-point vector slim convolution\n" },
  CompletionDef { label: "f16v4sisoamp", detail: "f16v4sisoamp $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*f16* accumulating matrix-vector product\n" },
  CompletionDef { label: "f16v4sisoslic", detail: "f16v4sisoslic $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*f16* slim convolution\n" },
  CompletionDef { label: "f16v4stacc", detail: "f16v4stacc $aDst0:Dst0+1 enumFlags", documentation: "Sort/shuffle (permute) through accumulators (no new input)\n" },
  CompletionDef { label: "f16v4sub", detail: "f16v4sub $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 2 more)", documentation: "*Half-precision* vector subtraction\n" },
  CompletionDef { label: "f16v4sufromui", detail: "f16v4sufromui $aDst0:Dst0+1 $aSrc0:Src0+1", documentation: "\n" },
  CompletionDef { label: "f16v4sum", detail: "f16v4sum $aDst0:Dst0+1 $aSrc0:Src0+1", documentation: "*Half-precision* vector 2x2 lateral summation\n" },
  CompletionDef { label: "f16v8absacc", detail: "f16v8absacc $aSrc0:Src0+3", documentation: "*Half-precision* 8-element vector accumulation of absolutes\n" },
  CompletionDef { label: "f16v8acc", detail: "f16v8acc $aSrc0:Src0+3", documentation: "*Half-precision* 8-element vector accumulate\n" },
  CompletionDef { label: "f16v8sqacc", detail: "f16v8sqacc $aSrc0:Src0+3", documentation: "*Half-precision* vector accumulate squares\n" },
  CompletionDef { label: "f32absadd", detail: "f32absadd $aDst0 $aSrc0 $aSrc1", documentation: "Scalar floating-point addition of absolutes\n" },
  CompletionDef { label: "f32absmax", detail: "f32absmax $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point max of absolute values\n" },
  CompletionDef { label: "f32add", detail: "f32add $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point addition\n" },
  CompletionDef { label: "f32clamp", detail: "f32clamp $aDst0 $aSrc0 $aSrc1:Src1+1", documentation: "*Single-precision* floating-point vector min-of-maximum\n" },
  CompletionDef { label: "f32class", detail: "f32class $aDst0 $aSrc0", documentation: "*Single-precision* floating-point number classifier\n" },
  CompletionDef { label: "f32cmpeq", detail: "f32cmpeq $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point equality test\n" },
  CompletionDef { label: "f32cmpge", detail: "f32cmpge $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point greater than or equal test\n" },
  CompletionDef { label: "f32cmpgt", detail: "f32cmpgt $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point greater than\n" },
  CompletionDef { label: "f32cmple", detail: "f32cmple $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point less or equal\n" },
  CompletionDef { label: "f32cmplt", detail: "f32cmplt $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point less than\n" },
  CompletionDef { label: "f32cmpne", detail: "f32cmpne $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point not equal\n" },
  CompletionDef { label: "f32div", detail: "f32div $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point division\n" },
  CompletionDef { label: "f32exp", detail: "f32exp $aDst0 $aSrc0", documentation: "\n" },
  CompletionDef { label: "f32exp2", detail: "f32exp2 $aDst0 $aSrc0", documentation: "\n" },
  CompletionDef { label: "f32fromi32", detail: "f32fromi32 $aDst0 $aSrc0", documentation: "Signed integer to :term:\\'single-precision\\` floating-point conversion\n" },
  CompletionDef { label: "f32fromui32", detail: "f32fromui32 $aDst0 $aSrc0", documentation: "Unsigned integer to :term:\\'single-precision\\` floating-point conversion\n" },
  CompletionDef { label: "f32int", detail: "f32int $aDst0 $aSrc1 enumRnd", documentation: "round to integral\n" },
  CompletionDef { label: "f32ln", detail: "f32ln $aDst0 $aSrc0", documentation: "\n" },
  CompletionDef { label: "f32log2", detail: "f32log2 $aDst0 $aSrc0", documentation: "Base 2 logarithm\n" },
  CompletionDef { label: "f32mac", detail: "f32mac $aSrc0 $aSrc1", documentation: "Single precision floating-point multiply and accumulate\n" },
  CompletionDef { label: "f32max", detail: "f32max $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point max\n" },
  CompletionDef { label: "f32min", detail: "f32min $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point min\n" },
  CompletionDef { label: "f32mul", detail: "f32mul $aDst0 $aSrc0 $aSrc1", documentation: "Single precision floating-point multiply\n" },
  CompletionDef { label: "f32oorx", detail: "f32oorx $aDst0 $aSrc0", documentation: "Floating-point reciprocal of square-root\n" },
  CompletionDef { label: "f32oox", detail: "f32oox $aDst0 $aSrc0", documentation: "Floating-point reciprocal\n" },
  CompletionDef { label: "f32sigm", detail: "f32sigm $aDst0 $aSrc0", documentation: "\n" },
  CompletionDef { label: "f32sisoamp", detail: "f32sisoamp $aDst0:Dst0+1 $aSrc0 $aSrc1:Src1+1 enumFlags", documentation: "*Single-precision* floating-point vector accumulating matrix-vector\nproduct\n" },
  CompletionDef { label: "f32sisoslic", detail: "f32sisoslic $aDst0:Dst0+1 $aSrc0 $aSrc1:Src1+1 enumFlags", documentation: "*Single-precision* floating-point slim convolution\n" },
  CompletionDef { label: "f32sqrt", detail: "f32sqrt $aDst0 $aSrc0", documentation: "Single precision square root\n" },
  CompletionDef { label: "f32sub", detail: "f32sub $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point subtract\n" },
  CompletionDef { label: "f32sufromui", detail: "f32sufromui $aDst0 $aSrc0", documentation: "\n" },
  CompletionDef { label: "f32tanh", detail: "f32tanh $aDst0 $aSrc0", documentation: "*Single-precision* floating-point hyperbolic tangent\n" },
  CompletionDef { label: "f32tof16", detail: "f32tof16 $aDst0 $aSrc0", documentation: "\n" },
  CompletionDef { label: "f32toi32", detail: "f32toi32 $aDst0 $aSrc0", documentation: "*Single-precision* floating-point to signed integer conversion\n" },
  CompletionDef { label: "f32toui32", detail: "f32toui32 $aDst0 $aSrc0", documentation: "*Single-precision* floating-point to unsigned integer conversion\n" },
  CompletionDef { label: "f32v2absadd", detail: "f32v2absadd $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* floating-point vector add of absolutes\n" },
  CompletionDef { label: "f32v2absmax", detail: "f32v2absmax $aDst0:Dst0+1 $aSrc1:Src1+1 $aSrc0:Src0+1", documentation: "*Single-precision* vector max of absolute values\n" },
  CompletionDef { label: "f32v2add", detail: "f32v2add $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector add\n" },
  CompletionDef { label: "f32v2aop", detail: "f32v2aop $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*Single-precision* vector accumulating outer-product\n" },
  CompletionDef { label: "f32v2axpy", detail: "f32v2axpy $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* 2-element vector z = ax + y\n" },
  CompletionDef { label: "f32v2clamp", detail: "f32v2clamp $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* floating-point vector min-of-maximum\n" },
  CompletionDef { label: "f32v2class", detail: "f32v2class $aDst0 $aSrc0:Src0+1", documentation: "*Single-precision* floating-point vector classifier\n" },
  CompletionDef { label: "f32v2cmpeq", detail: "f32v2cmpeq $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector equality test\n" },
  CompletionDef { label: "f32v2cmpge", detail: "f32v2cmpge $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector greater-than or equal-to test\n" },
  CompletionDef { label: "f32v2cmpgt", detail: "f32v2cmpgt $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector greater-than test\n" },
  CompletionDef { label: "f32v2cmple", detail: "f32v2cmple $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector less-than or equal-to test\n" },
  CompletionDef { label: "f32v2cmplt", detail: "f32v2cmplt $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector less-than test\n" },
  CompletionDef { label: "f32v2cmpne", detail: "f32v2cmpne $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector inequality test\n" },
  CompletionDef { label: "f32v2gina", detail: "f32v2gina $aDst0:Dst0+1 $aSrc0:Src0+1 zimm12", documentation: "Get and initialise accumulators\n" },
  CompletionDef { label: "f32v2grand", detail: "f32v2grand $aDst0:Dst0+1", documentation: "Gaussian distribution, 2-element *single-precision* random vector\n" },
  CompletionDef { label: "f32v2mac", detail: "f32v2mac $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector multiply and accumulate\n" },
  CompletionDef { label: "f32v2max", detail: "f32v2max $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector max\n" },
  CompletionDef { label: "f32v2min", detail: "f32v2min $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector min\n" },
  CompletionDef { label: "f32v2mul", detail: "f32v2mul $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector Hadamard product\n" },
  CompletionDef { label: "f32v2rmask", detail: "f32v2rmask $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1", documentation: "*Single-precision* vector random mask\n" },
  CompletionDef { label: "f32v2sub", detail: "f32v2sub $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 (and 1 more)", documentation: "*Single-precision* vector subtraction\n" },
  CompletionDef { label: "f32v2sufromui", detail: "f32v2sufromui $aDst0:Dst0+1 $aSrc0:Src0+1", documentation: "\n" },
  CompletionDef { label: "f32v2tof16", detail: "f32v2tof16 $aDst0 $aSrc0:Src0+1", documentation: "*Single-precision* pair to *f16* pair\n" },
  CompletionDef { label: "f32v4absacc", detail: "f32v4absacc $aSrc0:Src0+3", documentation: "*Single-precision* vector accumulation of absolutes\n" },
  CompletionDef { label: "f32v4acc", detail: "f32v4acc $aSrc0:Src0+3", documentation: "*Single-precision* vector accumulate\n" },
  CompletionDef { label: "f32v4sqacc", detail: "f32v4sqacc $aSrc0:Src0+3", documentation: "*Single-precision* vector accumulate squares\n" },
  CompletionDef { label: "f32v4tof16", detail: "f32v4tof16 $aDst0:Dst0+1 $aSrc0:Src0+3", documentation: "*Single-precision* 4-element vector to *f16* vector\n" },
  CompletionDef { label: "fnop", detail: "fnop", documentation: "`fnop`\n\nDo nothing for one cycle (aux pipeline). Alias for `or $azero, $azero, 0`\n" },
  CompletionDef { label: "get", detail: "get $mDst0 zimm8", documentation: "Lower control register read\n" },
  CompletionDef { label: "ld128", detail: "ld128 $aDst0:Dst0+3 $mBase0 $mDelta0 $mOff0 (and 1 more)", documentation: "Single 128-bit load from interleaved memory region\n" },
  CompletionDef { label: "ld128putcs", detail: "ld128putcs zimm8", documentation: "128-bit load and put to common configuration space\n" },
  CompletionDef { label: "ld128step", detail: "ld128step $aDst0:Dst0+3 $mBase0 $mDelta0+= simm8 (and 1 more)", documentation: "Post-incrementing 128-bit load from interleaved memory region.\n" },
  CompletionDef { label: "ld2x64pace", detail: "ld2x64pace $aDst0:Dst0+1 $aDst1:Dst1+1 $mAddr0:Addr0+1+= $mStride0 Strimm2x2", documentation: "Post-incrementing, dual 64-bit load\n" },
  CompletionDef { label: "ld2xst64pace", detail: "ld2xst64pace $aDst0:Dst0+3 $aSrc0:Src0+1 $mAddr0:Addr0+1+= $mStride0 Strimm3x2", documentation: "Post-incrementing dual 64-bit load with simultaneous 64-bit store.\n" },
  CompletionDef { label: "ld32", detail: "ld32 $mDst0 $mBase0 $mDelta0 $mOff0 (and 3 more)", documentation: "Single 32-bit load\n" },
  CompletionDef { label: "ld32step", detail: "ld32step $mDst0 $mBase0 $mDelta0+= simm8 (and 3 more)", documentation: "Post-incrementing *word* load\n" },
  CompletionDef { label: "ld64", detail: "ld64 $aDst0:Dst0+1 $mBase0 $mDelta0 $mOff0 (and 1 more)", documentation: "Single 64-bit load\n" },
  CompletionDef { label: "ld64a32", detail: "ld64a32 $aDst0+1:Dst0+3 $mAddr0++ $mBase0 $mDelta0", documentation: "Post-incrementing dense 64-bit plus sparse 32-bit load\n" },
  CompletionDef { label: "ld64a32pace", detail: "ld64a32pace $aDst0:Dst0+1 $aDst1 $mAddr0:Addr0+1+= $mStride0 Strimm2x2", documentation: "Post-incrementing dual 64/32-bit load\n" },
  CompletionDef { label: "ld64b16pace", detail: "ld64b16pace $aDst0:Dst0+1 $aDst1 $mAddr0:Addr0+1+= $mStride0 Strimm2x2", documentation: "Post-incrementing, dual 64/16-bit load\n" },
  CompletionDef { label: "ld64putcs", detail: "ld64putcs zimm8", documentation: "64-bit load and put to common configuration space\n" },
  CompletionDef { label: "ld64step", detail: "ld64step $aDst0:Dst0+1 $mBase0 $mDelta0+= simm8 (and 1 more)", documentation: "Post-incrementing 64-bit load\n" },
  CompletionDef { label: "ldb16", detail: "ldb16 $aDst0 $mBase0 $mDelta0 $mOff0 (and 1 more)", documentation: "16-bit load and broadcast\n" },
  CompletionDef { label: "ldb16b16", detail: "ldb16b16 $aDst0:Dst0+1 $mBase0 $mDelta0++ $mMiniD0&gt;&gt;", documentation: "Post-incrementing, lightly-sparse 16-bit with dense 16-bit load\n" },
  CompletionDef { label: "ldb16step", detail: "ldb16step $aDst0 $mBase0 $mDelta0+= simm8 (and 1 more)", documentation: "Post-incrementing 16-bit load and broadcast\n" },
  CompletionDef { label: "ldconst", detail: "ldconst $mDest zimm (and 2 more)", documentation: "Load a constant into a register. This can be used to load 32-bit constants which takes two actual instructions. This compiles to `setzi` instructions.\n" },
  CompletionDef { label: "ldd16a32", detail: "ldd16a32 $aDst0 $mAddr0++ $mBase0 $mDelta0@", documentation: "Post-incrementing 16-bit delta and 32-bit data load\n" },
  CompletionDef { label: "ldd16a64", detail: "ldd16a64 $aDst0:Dst0+1 $mAddr0++ $mBase0 $mDelta0@", documentation: "Post-incrementing 16-bit delta and 64-bit data load\n" },
  CompletionDef { label: "ldd16b16", detail: "ldd16b16 $aDst0 $mAddr0++ $mBase0 $mDelta0@", documentation: "Post-incrementing 16-bit delta and broadcast 16-bit data load\n" },
  CompletionDef { label: "ldd16v2a32", detail: "ldd16v2a32 $aDst0 $mAddr0++ $mBase0 $mDelta0@", documentation: "Post-incrementing delta-pair plus 32-bit load\n" },
  CompletionDef { label: "lds16", detail: "lds16 $mDst0 $mBase0 $mDelta0 $mOff0 (and 1 more)", documentation: "Sign extending 16-bit load\n" },
  CompletionDef { label: "lds16step", detail: "lds16step $mDst0 $mBase0 $mDelta0+= simm8 (and 1 more)", documentation: "Post-incrementing sign-extending 16-bit load\n" },
  CompletionDef { label: "lds8", detail: "lds8 $mDst0 $mBase0 $mDelta0 $mOff0 (and 1 more)", documentation: "Sign extending 8-bit load\n" },
  CompletionDef { label: "lds8step", detail: "lds8step $mDst0 $mBase0 $mDelta0+= simm8 (and 1 more)", documentation: "Post-incrementing sign-extending 8-bit load\n" },
  CompletionDef { label: "ldst64pace", detail: "ldst64pace $aDst0:Dst0+1 $aSrc0:Src0+1 $mAddr0:Addr0+1+= $mStride0 Strimm2x2", documentation: "Post-incrementing 64-bit load with simultaneous 64-bit store.\n" },
  CompletionDef { label: "ldz16", detail: "ldz16 $mDst0 $mBase0 $mDelta0 $mOff0 (and 1 more)", documentation: "Zero-extending 16-bit load\n" },
  CompletionDef { label: "ldz16step", detail: "ldz16step $mDst0 $mBase0 $mDelta0+= simm8 (and 1 more)", documentation: "Post-incrementing zero-extending 16-bit load\n" },
  CompletionDef { label: "ldz8", detail: "ldz8 $mDst0 $mBase0 $mDelta0 $mOff0 (and 1 more)", documentation: "Zero-extending 8-bit load\n" },
  CompletionDef { label: "ldz8step", detail: "ldz8step $mDst0 $mBase0 $mDelta0+= simm8 (and 1 more)", documentation: "Post-incrementing *zero extended* 8-bit load\n" },
  CompletionDef { label: "max", detail: "max $mDst0 $mSrc0 $mSrc1 (and 2 more)", documentation: "Maximum\n" },
  CompletionDef { label: "min", detail: "min $mDst0 $mSrc0 $mSrc1 (and 2 more)", documentation: "Minimum\n" },
  CompletionDef { label: "mov", detail: "mov $mDest $mSrc (and 2 more)", documentation: "Copy the value in `$mSrc` to `mDst`. This compiles to `or` or `atom` instructions.\n" },
  CompletionDef { label: "movz", detail: "movz $mSrcDst0 $mSrc0 $mSrc1", documentation: "Conditional move\n" },
  CompletionDef { label: "mul", detail: "mul $mDst0 $mSrc0 $mSrc1 (and 1 more)", documentation: "Signed multiplication\n" },
  CompletionDef { label: "nop", detail: "nop", documentation: "Do nothing for one cycle (main pipeline). Alias for `or $mzero, $mzero, 0`\n" },
  CompletionDef { label: "not", detail: "not $aDst0 $aSrc0", documentation: "32-bit bitwise logical NOT\n" },
  CompletionDef { label: "not64", detail: "not64 $aDst0:Dst0+1 $aSrc0:Src0+1", documentation: "64-bit bitwise logical NOT\n" },
  CompletionDef { label: "or", detail: "or $mDst0 $mSrc0 $mSrc1 (and 5 more)", documentation: "Bitwise OR\n" },
  CompletionDef { label: "or64", detail: "or64 $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "64-bit bitwise logical OR\n" },
  CompletionDef { label: "popc", detail: "popc $mDst0 $mSrc0", documentation: "Population count\n" },
  CompletionDef { label: "put", detail: "put zimm8 $mSrc0", documentation: "Write to a lower control register\n" },
  CompletionDef { label: "roll16", detail: "roll16 $mDst0 $mSrc0 $mSrc1 (and 1 more)", documentation: "roll16 SIMD permutation\n" },
  CompletionDef { label: "roll32", detail: "roll32 $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "roll32 SIMD permutation\n" },
  CompletionDef { label: "roll8l", detail: "roll8l $mDst0 $mSrc0 $mSrc1", documentation: "roll8-left SIMD permutation\n" },
  CompletionDef { label: "roll8r", detail: "roll8r $mDst0 $mSrc0 $mSrc1", documentation: "roll8-right SIMD permutation\n" },
  CompletionDef { label: "rpt", detail: "rpt $mSrc0 zimm8 (and 1 more)", documentation: "Repeat a sequence of *Execution Bundle*s\n" },
  CompletionDef { label: "run", detail: "run $mEntry0 $mVBase0 zimm16", documentation: "Launch a worker thread\n" },
  CompletionDef { label: "runall", detail: "runall $mEntry0 $mVBase0 zimm16", documentation: "Launch a batch of worker threads\n" },
  CompletionDef { label: "setzi", detail: "setzi $mDst0 zimm20 (and 1 more)", documentation: "Register set from immediate\n" },
  CompletionDef { label: "shl", detail: "shl $mDst0 $mSrc0 $mSrc1 (and 1 more)", documentation: "Logical shift left\n" },
  CompletionDef { label: "shr", detail: "shr $mDst0 $mSrc0 $mSrc1 (and 1 more)", documentation: "Logical shift right\n" },
  CompletionDef { label: "shrs", detail: "shrs $mDst0 $mSrc0 $mSrc1 (and 1 more)", documentation: "Signed (arithmetic) shift right\n" },
  CompletionDef { label: "shuf8x8hi", detail: "shuf8x8hi $mDst0 $mSrc0 $mSrc1", documentation: "8 x 8-bit SIMD permutation\n" },
  CompletionDef { label: "shuf8x8lo", detail: "shuf8x8lo $mDst0 $mSrc0 $mSrc1", documentation: "8 x 8-bit SIMD permutation\n" },
  CompletionDef { label: "sort4x16hi", detail: "sort4x16hi $mDst0 $mSrc0 $mSrc1 (and 2 more)", documentation: "4 x 16-bit SIMD permutation\n" },
  CompletionDef { label: "sort4x16lo", detail: "sort4x16lo $mDst0 $mSrc0 $mSrc1 (and 2 more)", documentation: "4 x 16-bit SIMD permutation\n" },
  CompletionDef { label: "sort4x32hi", detail: "sort4x32hi $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "4 x 32-bit SIMD permutation\n" },
  CompletionDef { label: "sort4x32lo", detail: "sort4x32lo $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "4 x 32-bit SIMD permutation\n" },
  CompletionDef { label: "sort8", detail: "sort8 $mDst0 $mSrc0", documentation: "4 x 8-bit SIMD permutation\n" },
  CompletionDef { label: "sort8x8hi", detail: "sort8x8hi $mDst0 $mSrc0 $mSrc1", documentation: "8 x 8-bit SIMD permutation\n" },
  CompletionDef { label: "sort8x8lo", detail: "sort8x8lo $mDst0 $mSrc0 $mSrc1", documentation: "8 x 8-bit SIMD permutation\n" },
  CompletionDef { label: "st32", detail: "st32 $aSrc0 $mBase0 $mDelta0 $mOffset0 (and 2 more)", documentation: "32-bit store\n" },
  CompletionDef { label: "st32step", detail: "st32step $mSrc0 $mBase0 $mDelta0+= simm8 (and 2 more)", documentation: "Post-incrementing 32-bit store\n" },
  CompletionDef { label: "st64", detail: "st64 $aSrc0:Src0+1 $mBase0 $mDelta0 $mOffset0 (and 1 more)", documentation: "64-bit store\n" },
  CompletionDef { label: "st64pace", detail: "st64pace $aSrc0:Src0+1 $mAddr0:Addr0+1+= $mStride0 Strimm2", documentation: "Post-incrementing 64-bit store, using packed addresses and offsets\n" },
  CompletionDef { label: "st64step", detail: "st64step $aSrc0:Src0+1 $mBase0 $mDelta0+= simm8 (and 1 more)", documentation: "Post-incrementing 64-bit store\n" },
  CompletionDef { label: "stm32", detail: "stm32 $mSrc0 $mBase0 $mOffset0", documentation: "32-bit store from MRF\n" },
  CompletionDef { label: "stm32step", detail: "stm32step $mSrc0 $mBase0+= $mStride0", documentation: "Post-incrementing 32-bit store from MRF\n" },
  CompletionDef { label: "sub", detail: "sub $mDst0 $mSrc1 $mSrc0 (and 2 more)", documentation: "Subtraction\n" },
  CompletionDef { label: "swap8", detail: "swap8 $mDst0 $mSrc0", documentation: "4 x 8-bit SIMD permutation\n" },
  CompletionDef { label: "tapack", detail: "tapack $mDst0:Dst0+1 $mAddr0 $mAddr1 $mAddr2", documentation: "Triple address pack\n" },
  CompletionDef { label: "trap", detail: "trap zimm4", documentation: "Patched BREAKPOINT\n" },
  CompletionDef { label: "uget", detail: "uget $aDst0 zimm8", documentation: "Upper control register read\n" },
  CompletionDef { label: "uput", detail: "uput zimm8 $aSrc0", documentation: "Write to an upper control register\n" },
  CompletionDef { label: "urand32", detail: "urand32 $aDst0", documentation: "Uniform distribution, 32-bit random integer\n" },
  CompletionDef { label: "urand64", detail: "urand64 $aDst0:Dst0+1", documentation: "Uniform distribution, 64-bit random integer\n" },
  CompletionDef { label: "xnor", detail: "xnor $mDst0 $mSrc0 $mSrc1", documentation: "Bitwise NOT XOR\n" },
  CompletionDef { label: "xor", detail: "xor $mDst0 $mSrc0 $mSrc1", documentation: "Bitwise XOR\n" },
  CompletionDef { label: "zero", detail: "zero $mDest (and 2 more)", documentation: "Zero the register. Alias for `or $mDest, $mzero, 0`, `or $aDest, $azero, 0` or `or64 $aDest:1, $azeros, 0`.\n" },
];
pub static COMPLETION_RANGES: phf::Map<&'static str, std::ops::Range<usize>> = ::phf::Map {
    key: 12913932095322966823,
    disps: &[
        (1, 59),
        (0, 81),
        (0, 6),
        (0, 8),
        (0, 163),
        (0, 726),
        (0, 172),
        (0, 56),
        (1, 406),
        (0, 243),
        (0, 435),
        (0, 108),
        (0, 494),
        (0, 116),
        (0, 11),
        (0, 672),
        (0, 2),
        (0, 4),
        (0, 39),
        (0, 4),
        (0, 126),
        (0, 296),
        (2, 273),
        (1, 2),
        (0, 22),
        (1, 31),
        (0, 1),
        (0, 516),
        (0, 132),
        (0, 214),
        (0, 269),
        (0, 208),
        (0, 10),
        (0, 3),
        (0, 0),
        (0, 338),
        (0, 117),
        (0, 30),
        (0, 28),
        (0, 20),
        (0, 57),
        (0, 1),
        (0, 36),
        (1, 884),
        (0, 2),
        (0, 42),
        (0, 3),
        (0, 35),
        (0, 0),
        (0, 0),
        (1, 913),
        (0, 136),
        (0, 2),
        (0, 0),
        (0, 36),
        (0, 62),
        (0, 3),
        (0, 0),
        (1, 940),
        (0, 13),
        (0, 3),
        (0, 40),
        (0, 392),
        (0, 2),
        (0, 490),
        (5, 439),
        (0, 64),
        (0, 91),
        (0, 2),
        (0, 40),
        (0, 3),
        (0, 1),
        (0, 53),
        (1, 549),
        (0, 20),
        (4, 607),
        (0, 358),
        (0, 7),
        (1, 79),
        (0, 23),
        (1, 772),
        (0, 749),
        (1, 718),
        (0, 1),
        (0, 33),
        (0, 275),
        (0, 66),
        (0, 1),
        (2, 451),
        (0, 0),
        (0, 3),
        (0, 1),
        (0, 5),
        (0, 2),
        (1, 619),
        (2, 679),
        (0, 373),
        (1, 547),
        (0, 337),
        (2, 256),
        (0, 103),
        (0, 413),
        (0, 0),
        (0, 61),
        (0, 685),
        (0, 3),
        (8, 358),
        (0, 264),
        (0, 14),
        (1, 374),
        (0, 746),
        (13, 246),
        (0, 867),
        (0, 10),
        (0, 46),
        (0, 624),
        (5, 230),
        (0, 291),
        (0, 79),
        (0, 1),
        (0, 1),
        (0, 38),
        (0, 14),
        (3, 245),
        (0, 13),
        (4, 536),
        (0, 1),
        (0, 188),
        (0, 142),
        (0, 84),
        (0, 638),
        (0, 4),
        (2, 820),
        (0, 224),
        (0, 3),
        (0, 37),
        (2, 889),
        (0, 54),
        (0, 32),
        (2, 111),
        (6, 669),
        (0, 80),
        (137, 219),
        (0, 14),
        (0, 104),
        (0, 4),
        (0, 0),
        (0, 0),
        (0, 1),
        (1, 140),
        (0, 878),
        (0, 24),
        (0, 1),
        (0, 115),
        (1, 697),
        (0, 455),
        (0, 1),
        (12, 755),
        (0, 60),
        (15, 387),
        (0, 7),
        (0, 340),
        (0, 125),
        (0, 91),
        (0, 24),
        (1, 29),
        (0, 36),
        (0, 563),
        (0, 21),
        (6, 189),
        (8, 904),
        (0, 446),
        (0, 364),
        (0, 478),
        (4, 635),
        (0, 4),
        (0, 2),
        (0, 579),
        (0, 14),
        (10, 227),
        (0, 294),
        (2, 702),
        (0, 2),
        (0, 36),
        (26, 164),
        (0, 315),
        (4, 357),
        (0, 27),
        (0, 100),
    ],
    entries: &[
        ("f32v2clamp", 191..192),
        ("ld", 215..245),
        ("sort8x8h", 275..276),
        ("shuf", 268..270),
        ("lds8ste", 239..240),
        ("$TAS", 19..20),
        ("sort8", 274..277),
        ("f16v4hih", 131..133),
        ("f32v4sqa", 211..212),
        ("f16v4ac", 119..120),
        ("f32v2cmp", 193..199),
        ("roll16", 257..258),
        ("ld128putcs", 216..217),
        ("f32toui", 185..186),
        ("$a4", 31..33),
        ("f32v2rma", 205..206),
        ("$FP_STS", 9..10),
        ("fn", 213..214),
        ("$a4:", 32..33),
        ("l", 215..245),
        ("f32fromui32", 166..167),
        ("f16v4min", 136..137),
        ("f32v2mac", 201..202),
        ("e", 83..87),
        ("$WO", 21..22),
        ("f32v2mi", 203..204),
        ("ldd16a3", 232..233),
        ("f32v2cmpeq", 193..194),
        ("$mwo", 58..59),
        ("ld64b16p", 225..226),
        ("and6", 64..65),
        ("ura", 290..292),
        ("f16v2cmpe", 94..95),
        ("$m3", 50..51),
        ("$REPEAT_FI", 18..19),
        ("f16v2gran", 103..104),
        ("f16v2l", 104..106),
        ("$DBG_DA", 5..6),
        ("f16v2su", 111..114),
        ("$REPEAT_E", 17..18),
        ("f16v2ex", 100..102),
        ("f16v2cmpn", 99..100),
        ("cmpult", 81..82),
        ("f16v4add", 120..121),
        ("f16v4st", 144..145),
        ("brpos", 74..75),
        ("f32min", 172..173),
        ("f32tof16", 183..184),
        ("f16v2maxc", 107..108),
        ("mov", 247..249),
        ("f16v2add", 90..91),
        ("runall", 263..264),
        ("b", 68..76),
        ("add", 62..63),
        ("$a15", 27..28),
        ("st32st", 278..279),
        ("$WORKER_BAS", 21..22),
        ("f16tof", 87..88),
        ("$CCCSLO", 0..1),
        ("$DBG_", 4..6),
        ("mi", 246..247),
        ("f16t", 87..88),
        ("f32cmpl", 159..161),
        ("$FP_ICT", 8..9),
        ("no", 250..253),
        ("$WORKE", 21..22),
        ("ldd1", 232..236),
        ("f32fromui", 166..167),
        ("bi", 68..69),
        ("$WORKER_", 21..22),
        ("trap", 287..288),
        ("sort4x32hi", 272..273),
        ("$mverte", 57..58),
        ("$FP_S", 9..10),
        ("f32o", 174..176),
        ("exitpo", 85..86),
        ("exit", 83..87),
        ("$WORKER", 21..22),
        ("f16v4abs", 116..119),
        ("$REPEAT_COU", 16..17),
        ("zer", 294..295),
        ("f16v2absmax", 89..90),
        ("f16v2grand", 103..104),
        ("f16v4class", 122..123),
        ("brn", 71..74),
        ("ldb16b1", 229..230),
        ("f16v2clas", 92..93),
        ("ld64pu", 226..227),
        ("f32siso", 177..179),
        ("$REPEAT_COUNT", 16..17),
        ("f32v4sq", 211..212),
        ("f16v4istac", 133..134),
        ("f32v2r", 205..206),
        ("f16v2sig", 110..111),
        ("$FP_ICTL", 8..9),
        ("$a7", 36..37),
        ("ldco", 231..232),
        ("f16v4mu", 138..139),
        ("f32v", 186..213),
        ("swap", 285..286),
        ("f32tof1", 183..184),
        ("f32v2sufro", 207..208),
        ("ld2", 218..220),
        ("f16v4siso", 142..144),
        ("f16v2cla", 91..93),
        ("up", 289..290),
        ("lds8", 238..240),
        ("$DBG_B", 4..5),
        ("$VERTEX_BA", 20..21),
        ("sort4x32l", 273..274),
        ("f32toi32", 184..185),
        ("stm32ste", 283..284),
        ("bitrev8", 68..69),
        ("f32toui32", 185..186),
        ("f32v4ab", 209..210),
        ("movz", 248..249),
        ("sort8x", 275..277),
        ("ld64b16pace", 225..226),
        ("$WOR", 21..22),
        ("f32v4s", 211..212),
        ("f32absm", 152..153),
        ("ldz", 241..245),
        ("$aze", 37..39),
        ("f32v2absa", 186..187),
        ("f16v4sta", 144..145),
        ("f16v2e", 100..102),
        ("tr", 287..288),
        ("f16v4sub", 145..146),
        ("p", 255..257),
        ("f32v4", 209..213),
        ("f16v4sihoam", 140..141),
        ("lds16s", 237..238),
        ("f32tof", 183..184),
        ("$", 0..61),
        ("f16v4hihoamp", 131..132),
        ("f16v4cm", 123..130),
        ("$sp", 60..61),
        ("ldcons", 231..232),
        ("run", 262..264),
        ("ld2x64pa", 218..219),
        ("shr", 266..268),
        ("ex", 83..87),
        ("f32absad", 151..152),
        ("f32lo", 169..170),
        ("f32v2ma", 201..203),
        ("f16v2a", 88..91),
        ("$REPEAT_FIR", 18..19),
        ("$a2:", 29..30),
        ("f16v4sufro", 146..147),
        ("st64p", 280..281),
        ("f32cmplt", 160..161),
        ("$D", 4..6),
        ("$CTXT_S", 3..4),
        ("f32v2cmpn", 198..199),
        ("f32mu", 173..174),
        ("zero", 294..295),
        ("f32sisosl", 178..179),
        ("$CO", 1..3),
        ("f16v2cmpl", 97..99),
        ("f32v2cmple", 196..197),
        ("f16v4hihoslic", 132..133),
        ("f16v4cmpeq", 124..125),
        ("lds16ste", 237..238),
        ("ldst64p", 240..241),
        ("ld32s", 221..222),
        ("f32a", 151..154),
        ("f32class", 155..156),
        ("f16v2ma", 106..108),
        ("$R", 16..19),
        ("$m9", 56..57),
        ("$PRNG", 11..16),
        ("f32cl", 154..156),
        ("ld2x64", 218..219),
        ("f", 87..214),
        ("f32v4absa", 209..210),
        ("ldz16step", 242..243),
        ("ld32", 220..222),
        ("ldst", 240..241),
        ("f32v2sufr", 207..208),
        ("$m4", 51..52),
        ("f3", 151..213),
        ("andc64", 66..67),
        ("f16v4rm", 139..140),
        ("f16v2s", 110..114),
        ("f32clam", 154..155),
        ("ld3", 220..222),
        ("$FP_IC", 8..9),
        ("f16v4maxc", 135..136),
        ("f16v2cmpeq", 94..95),
        ("$F", 6..10),
        ("f32v2abs", 186..188),
        ("f16v2sigm", 110..111),
        ("$WORKER_B", 21..22),
        ("f32sisoslic", 178..179),
        ("uge", 288..289),
        ("f32fro", 165..167),
        ("f16v2cmpne", 99..100),
        ("so", 270..277),
        ("cmpslt", 80..81),
        ("cms", 82..83),
        ("f32cmple", 159..160),
        ("ldst64", 240..241),
        ("f16v2cmpgt", 96..97),
        ("ldz8s", 244..245),
        ("f32v2gi", 199..200),
        ("mul", 249..250),
        ("f32v4tof", 212..213),
        ("$a2", 28..30),
        ("f16v2si", 110..111),
        ("min", 246..247),
        ("$PC", 10..11),
        ("f16v2absad", 88..89),
        ("f16v2m", 106..110),
        ("f16v4c", 121..130),
        ("urand", 290..292),
        ("f16v8ac", 149..150),
        ("st32ste", 278..279),
        ("cl", 77..78),
        ("ldd16a32", 232..233),
        ("$PRNG_SEED", 15..16),
        ("$a5", 33..34),
        ("f32v2absma", 187..188),
        ("f32toi3", 184..185),
        ("ld6", 222..228),
        ("$VERTEX", 20..21),
        ("f32l", 168..170),
        ("xno", 292..293),
        ("$CTXT", 3..4),
        ("ldc", 231..232),
        ("f32f", 165..167),
        ("f32sufromui", 181..182),
        ("$l", 40..41),
        ("ze", 294..295),
        ("f32v4abs", 209..210),
        ("f16v4max", 134..136),
        ("f16v4clamp", 121..122),
        ("su", 284..285),
        ("f16v2cma", 93..94),
        ("ld64step", 227..228),
        ("$mworker_", 58..59),
        ("f16v4mix", 137..138),
        ("st64s", 281..282),
        ("at", 67..68),
        ("f16v4absm", 118..119),
        ("ldb16", 228..231),
        ("$m10", 43..44),
        ("f32suf", 181..182),
        ("ld128ste", 217..218),
        ("shuf8x", 268..270),
        ("sort4", 270..274),
        ("f16v8", 148..151),
        ("f16v4cmac", 123..124),
        ("sort4x16l", 271..272),
        ("ldz16", 241..243),
        ("$VE", 20..21),
        ("f16v4hi", 131..133),
        ("$f", 39..40),
        ("f16v4mi", 136..138),
        ("st64pac", 280..281),
        ("ld64b", 225..226),
        ("f16v4sufrom", 146..147),
        ("$m7", 54..55),
        ("sort4x16h", 270..271),
        ("f32v4acc", 210..211),
        ("ldcon", 231..232),
        ("xo", 293..294),
        ("and", 63..67),
        ("ru", 262..264),
        ("f16v2clam", 91..92),
        ("f16v4rmask", 139..140),
        ("f32sigm", 176..177),
        ("$CCCSLOAD", 0..1),
        ("swa", 285..286),
        ("$m15", 48..49),
        ("ldb16ste", 230..231),
        ("f32v2aop", 189..190),
        ("f32v2t", 208..209),
        ("f16v4sis", 142..144),
        ("$a6:", 35..36),
        ("f32v2cl", 191..193),
        ("f16v4absmax", 118..119),
        ("$m14", 47..48),
        ("f32sig", 176..177),
        ("ldd16v2a", 235..236),
        ("f16v4sisoslic", 143..144),
        ("f32v2rm", 205..206),
        ("$a3", 30..31),
        ("f16v2class", 92..93),
        ("f16v4sisosl", 143..144),
        ("$WS", 22..23),
        ("f32v4to", 212..213),
        ("roll3", 258..259),
        ("f16v2cmp", 94..100),
        ("uput", 289..290),
        ("sort", 270..277),
        ("$azer", 37..39),
        ("f1", 87..151),
        ("$DBG", 4..6),
        ("$mwork", 58..59),
        ("$WSR", 22..23),
        ("sort4x32h", 272..273),
        ("exitn", 83..85),
        ("$m2", 49..50),
        ("f16v4sihos", 141..142),
        ("ldd16a6", 233..234),
        ("f32v4tof1", 212..213),
        ("f32v2class", 192..193),
        ("ld64", 222..228),
        ("f16v4sisos", 143..144),
        ("f16v4sisosli", 143..144),
        ("f16v4rmas", 139..140),
        ("f32abs", 151..153),
        ("f16v4absad", 117..118),
        ("f16v4cmpn", 129..130),
        ("f32sufro", 181..182),
        ("f32v2sufromu", 207..208),
        ("ab", 61..62),
        ("f16tof3", 87..88),
        ("m", 245..250),
        ("exitne", 83..84),
        ("sw", 285..286),
        ("f16v4a", 116..121),
        ("f16v2g", 102..104),
        ("f16v4absa", 116..118),
        ("$FP", 6..10),
        ("$VERTE", 20..21),
        ("st32", 277..279),
        ("ld128putc", 216..217),
        ("f32v2axpy", 190..191),
        ("f32fromi32", 165..166),
        ("st", 277..284),
        ("f16v2cmac", 93..94),
        ("$WORK", 21..22),
        ("exi", 83..87),
        ("f16v2sufr", 112..113),
        ("f16v4hihosl", 132..133),
        ("stm3", 282..284),
        ("f16v4sih", 140..142),
        ("urand3", 290..291),
        ("$CTXT_ST", 3..4),
        ("f32cmpne", 161..162),
        ("f16v2lo", 105..106),
        ("$REPEAT_FIRS", 18..19),
        ("$FP_ST", 9..10),
        ("f16v2gin", 102..103),
        ("f16v2ln", 104..105),
        ("$REPEAT_CO", 16..17),
        ("po", 255..256),
        ("f16v2absm", 89..90),
        ("cmpu", 81..82),
        ("$V", 20..21),
        ("rol", 257..261),
        ("setzi", 264..265),
        ("f32ad", 153..154),
        ("popc", 255..256),
        ("ldst64pace", 240..241),
        ("$azero", 37..39),
        ("ge", 214..215),
        ("f16v2tof3", 115..116),
        ("f32v2max", 202..203),
        ("$VERT", 20..21),
        ("f16v4cmpg", 125..127),
        ("cmpeq", 78..79),
        ("xnor", 292..293),
        ("f32exp2", 164..165),
        ("f16v4gacc", 130..131),
        ("$mvertex_b", 57..58),
        ("f16v2mul", 109..110),
        ("f32absmax", 152..153),
        ("$FP_CTL", 7..8),
        ("$PRNG_0_0", 11..12),
        ("f16v8sq", 150..151),
        ("$m5", 52..53),
        ("f16v2gina", 102..103),
        ("$COUNT_U", 2..3),
        ("$FP_CLR", 6..7),
        ("ldd16a", 232..234),
        ("f32v2mul", 204..205),
        ("fnop", 213..214),
        ("f32v2sufrom", 207..208),
        ("$WORKER_BASE", 21..22),
        ("f16v8ab", 148..149),
        ("ld2x64p", 218..219),
        ("f16v4sihoamp", 140..141),
        ("set", 264..265),
        ("f32clamp", 154..155),
        ("f32v2ab", 186..188),
        ("f32v2g", 199..201),
        ("$mvertex_base", 57..58),
        ("f32v2axp", 190..191),
        ("shuf8x8hi", 268..269),
        ("f32cm", 156..162),
        ("$VER", 20..21),
        ("f32v2tof", 208..209),
        ("f32v2cmpl", 196..198),
        ("or64", 254..255),
        ("f16v4ma", 134..136),
        ("f32v2cmpe", 193..194),
        ("ld64putc", 226..227),
        ("f16v4ad", 120..121),
        ("st64pa", 280..281),
        ("$RE", 16..19),
        ("f32si", 176..179),
        ("f32cmpn", 161..162),
        ("stm32step", 283..284),
        ("$REPEAT_F", 18..19),
        ("sort8x8lo", 276..277),
        ("$PRNG_SEE", 15..16),
        ("z", 294..295),
        ("sub", 284..285),
        ("f32v2cmpge", 194..195),
        ("f32v2grand", 200..201),
        ("u", 288..292),
        ("f32di", 162..163),
        ("$m11", 44..45),
        ("sort4x32", 272..274),
        ("$mwor", 58..59),
        ("$REPEAT_EN", 17..18),
        ("f32v2cm", 193..199),
        ("f16v8sqa", 150..151),
        ("$CTXT_STS", 3..4),
        ("cmp", 78..82),
        ("f16v2t", 114..116),
        ("ldb16step", 230..231),
        ("$DBG_BR", 4..5),
        ("sort4x", 270..274),
        ("ld2x", 218..220),
        ("f32v2", 186..209),
        ("ldz8st", 244..245),
        ("stm", 282..284),
        ("brne", 71..72),
        ("f16v4s", 140..148),
        ("f32v2rmas", 205..206),
        ("$mvertex_", 57..58),
        ("sort4x32lo", 273..274),
        ("and64", 64..65),
        ("f32mul", 173..174),
        ("ldst64pac", 240..241),
        ("$REP", 16..19),
        ("exitneg", 83..84),
        ("$mvert", 57..58),
        ("$PRNG_0_1", 12..13),
        ("$mvertex_ba", 57..58),
        ("f16v8sqacc", 150..151),
        ("f32int", 167..168),
        ("f16v2clamp", 91..92),
        ("f16v4sisoa", 142..143),
        ("f16v4cla", 121..123),
        ("$m", 41..60),
        ("ldb16s", 230..231),
        ("pop", 255..256),
        ("f32sisos", 178..179),
        ("ld64s", 227..228),
        ("f16v8absa", 148..149),
        ("roll", 257..261),
        ("$mworker", 58..59),
        ("$FP_CT", 7..8),
        ("lds8st", 239..240),
        ("sort4x1", 270..272),
        ("cm", 78..83),
        ("roll32", 258..259),
        ("f32ln", 168..169),
        ("$a6", 34..36),
        ("f32v2su", 206..208),
        ("clz", 77..78),
        ("f16v4hihoam", 131..132),
        ("f32clas", 155..156),
        ("brz", 75..76),
        ("ur", 290..292),
        ("$W", 21..23),
        ("f16v2exp2", 101..102),
        ("f32absadd", 151..152),
        ("f32to", 183..186),
        ("ldz16st", 242..243),
        ("$azeros", 38..39),
        ("$DBG_BRK", 4..5),
        ("ld64st", 227..228),
        ("andc", 65..67),
        ("ld64b1", 225..226),
        ("f32max", 171..172),
        ("ldb16b", 229..230),
        ("atom", 67..68),
        ("cmpn", 79..80),
        ("max", 245..246),
        ("st32s", 278..279),
        ("tap", 286..287),
        ("f16v8abs", 148..149),
        ("f16v4acc", 119..120),
        ("lds8step", 239..240),
        ("f32t", 182..186),
        ("f32tanh", 182..183),
        ("f16v2max", 106..108),
        ("st3", 277..279),
        ("ldz16ste", 242..243),
        ("f16v4sisoamp", 142..143),
        ("f16v2log2", 105..106),
        ("brnz", 72..74),
        ("$mvertex", 57..58),
        ("f16v4hihosli", 132..133),
        ("f16v4hiho", 131..133),
        ("ld2x64pac", 218..219),
        ("f16v8sqac", 150..151),
        ("urand64", 291..292),
        ("$COUN", 1..3),
        ("ld64a32pac", 224..225),
        ("f32cmpgt", 158..159),
        ("lds16st", 237..238),
        ("f32sqrt", 179..180),
        ("f32absa", 151..152),
        ("f16v4sufr", 146..147),
        ("stm32", 282..284),
        ("br", 69..76),
        ("roll8r", 260..261),
        ("urand6", 291..292),
        ("f32ma", 170..172),
        ("f32toi", 184..185),
        ("f32sq", 179..180),
        ("f32absma", 152..153),
        ("ld64ste", 227..228),
        ("ldz8ste", 244..245),
        ("f32v2sub", 206..207),
        ("$C", 0..4),
        ("f32ta", 182..183),
        ("ld64a32p", 224..225),
        ("$DBG_BRK_", 4..5),
        ("f16v4sihosli", 141..142),
        ("brnzde", 73..74),
        ("bitre", 68..69),
        ("f32sis", 177..179),
        ("f16v4absma", 118..119),
        ("$m0", 41..42),
        ("$a0:", 24..25),
        ("shu", 268..270),
        ("ta", 286..287),
        ("$REPEAT_COUN", 16..17),
        ("ld64a32", 223..225),
        ("or6", 254..255),
        ("f16v4clas", 122..123),
        ("$WORKER_BA", 21..22),
        ("ldd16v2", 235..236),
        ("f16v8absac", 148..149),
        ("$DBG_D", 5..6),
        ("$DB", 4..6),
        ("f16v2cmple", 97..98),
        ("f32sisoamp", 177..178),
        ("$PRNG_1_0", 13..14),
        ("f16v2sufrom", 112..113),
        ("$mve", 57..58),
        ("$a0:1", 24..25),
        ("$mv", 57..58),
        ("uran", 290..292),
        ("ldd16", 232..236),
        ("f16v2tof", 115..116),
        ("ldz1", 241..243),
        ("ro", 257..261),
        ("f32fromu", 166..167),
        ("f16to", 87..88),
        ("$PRNG_1_", 13..15),
        ("f16v2ab", 88..90),
        ("f32fromui3", 166..167),
        ("setz", 264..265),
        ("f32v2to", 208..209),
        ("f16tof32", 87..88),
        ("f32v2sufromui", 207..208),
        ("st64st", 281..282),
        ("lds8s", 239..240),
        ("f16v", 88..151),
        ("ld128p", 216..217),
        ("sort4x3", 272..274),
        ("f32tou", 185..186),
        ("f16v2sub", 111..112),
        ("ldd", 232..236),
        ("sor", 270..277),
        ("$m8", 55..56),
        ("ld64put", 226..227),
        ("f16v4gac", 130..131),
        ("f16v4si", 140..144),
        ("ld64a32pace", 224..225),
        ("f32v2absm", 187..188),
        ("ld2xst6", 219..220),
        ("f16v8absacc", 148..149),
        ("$T", 19..20),
        ("sort8x8", 275..277),
        ("andc6", 66..67),
        ("st32step", 278..279),
        ("f16v4cmpl", 127..129),
        ("ldconst", 231..232),
        ("f16v2to", 115..116),
        ("t", 286..288),
        ("ldd16v", 235..236),
        ("$PRNG_0", 11..13),
        ("$FP_C", 6..8),
        ("f16v8s", 150..151),
        ("f32c", 154..162),
        ("ad", 62..63),
        ("f16v2", 88..116),
        ("f32v4absacc", 209..210),
        ("urand32", 290..291),
        ("f16", 87..151),
        ("f16v4sihoa", 140..141),
        ("f16v4i", 133..134),
        ("ldb16st", 230..231),
        ("shl", 265..266),
        ("lds16", 236..238),
        ("f32su", 180..182),
        ("brp", 74..75),
        ("f32v2absmax", 187..188),
        ("x", 292..294),
        ("f32m", 170..174),
        ("f32v2c", 191..199),
        ("ldd16v2a32", 235..236),
        ("ld128s", 217..218),
        ("f32fromi3", 165..166),
        ("ld128", 215..218),
        ("$m12", 45..46),
        ("f16v4absac", 116..117),
        ("roll8", 259..261),
        ("f16v4h", 131..133),
        ("tapac", 286..287),
        ("$CT", 3..4),
        ("f16v4absacc", 116..117),
        ("ld128step", 217..218),
        ("f32v2gina", 199..200),
        ("$CCC", 0..1),
        ("f32v2gra", 200..201),
        ("f16v4sihosl", 141..142),
        ("f32v2clam", 191..192),
        ("ld32ste", 221..222),
        ("f16v4cma", 123..124),
        ("$a6:7", 35..36),
        ("f16v2mi", 108..109),
        ("ldb16b16", 229..230),
        ("f32v2cmpg", 194..196),
        ("roll1", 257..258),
        ("f32s", 176..182),
        ("$PRNG_S", 15..16),
        ("ld128put", 216..217),
        ("brnzd", 73..74),
        ("nop", 250..251),
        ("ca", 76..77),
        ("f16v2suf", 112..113),
        ("mu", 249..250),
        ("lds1", 236..238),
        ("sort4x16lo", 271..272),
        ("f16v2tan", 114..115),
        ("f32v2tof1", 208..209),
        ("stm32s", 283..284),
        ("n", 250..253),
        ("$m6", 53..54),
        ("f16v4su", 145..148),
        ("f32v2m", 201..205),
        ("$VERTEX_B", 20..21),
        ("f32e", 163..165),
        ("exitnz", 84..85),
        ("f16v4cmpge", 125..126),
        ("$COUNT_L", 1..2),
        ("upu", 289..290),
        ("f16v4suf", 146..147),
        ("$a14", 26..27),
        ("f32oor", 174..175),
        ("f32sufrom", 181..182),
        ("se", 264..265),
        ("f32v2cmpne", 198..199),
        ("$COUNT", 1..3),
        ("f32v2absadd", 186..187),
        ("f32sisosli", 178..179),
        ("f32v4sqacc", 211..212),
        ("brnzdec", 73..74),
        ("f16v4rma", 139..140),
        ("bit", 68..69),
        ("f16v4clam", 121..122),
        ("f32sisoam", 177..178),
        ("g", 214..215),
        ("$CC", 0..1),
        ("ldb", 228..231),
        ("exitp", 85..86),
        ("f16v4stacc", 144..145),
        ("$PR", 11..16),
        ("f32toui3", 185..186),
        ("f32cmpge", 157..158),
        ("ld64a3", 223..225),
        ("f16v8a", 148..150),
        ("$CTX", 3..4),
        ("f16v4hihoa", 131..132),
        ("$REPEAT_FIRST", 18..19),
        ("sort4x16hi", 270..271),
        ("$CTXT_", 3..4),
        ("f32v2add", 188..189),
        ("$REPE", 16..19),
        ("f32v2gran", 200..201),
        ("f32d", 162..163),
        ("$P", 10..16),
        ("tra", 287..288),
        ("f32v2rmask", 205..206),
        ("fno", 213..214),
        ("$mze", 59..60),
        ("f32v2ad", 188..189),
        ("xn", 292..293),
        ("put", 256..257),
        ("f16v4cmpgt", 126..127),
        ("ld128pu", 216..217),
        ("f16v4cl", 121..123),
        ("exitz", 86..87),
        ("runal", 263..264),
        ("lds", 236..241),
        ("$REPEAT_", 16..19),
        ("f32sufromu", 181..182),
        ("f32add", 153..154),
        ("$DBG_BRK_ID", 4..5),
        ("f16v8acc", 149..150),
        ("$mworker_base", 58..59),
        ("f32cmpg", 157..159),
        ("f32v2cmplt", 197..198),
        ("$PRNG_1_1", 14..15),
        ("$DBG_DATA", 5..6),
        ("f32v2cmpgt", 195..196),
        ("f32v4absac", 209..210),
        ("ld64b16", 225..226),
        ("roll8l", 259..260),
        ("$CCCS", 0..1),
        ("f16v2sufromui", 112..113),
        ("f32v2cla", 191..193),
        ("f16v2tanh", 114..115),
        ("$CCCSL", 0..1),
        ("cmpul", 81..82),
        ("f16v4sufromui", 146..147),
        ("ldd16a64", 233..234),
        ("f16v4cmp", 124..130),
        ("$mver", 57..58),
        ("$DBG_DAT", 5..6),
        ("f32cmp", 156..162),
        ("sort8x8l", 276..277),
        ("ato", 67..68),
        ("$a4:5", 32..33),
        ("tapa", 286..287),
        ("$COU", 1..3),
        ("$mzer", 59..60),
        ("f16v2cmplt", 98..99),
        ("f16v4g", 130..131),
        ("$a2:3", 29..30),
        ("f32v2gin", 199..200),
        ("not64", 252..253),
        ("f16v4hihos", 132..133),
        ("ma", 245..246),
        ("f32fr", 165..167),
        ("f16v2sufro", 112..113),
        ("ld64a32pa", 224..225),
        ("f16v4sihoslic", 141..142),
        ("ld64p", 226..227),
        ("exitpos", 85..86),
        ("rpt", 261..262),
        ("f32v2tof16", 208..209),
        ("$REPEAT", 16..19),
        ("mo", 247..249),
        ("$a0", 23..25),
        ("f32v4tof16", 212..213),
        ("f16v4stac", 144..145),
        ("f32sufr", 181..182),
        ("f16v4absadd", 117..118),
        ("$s", 60..61),
        ("f32exp", 163..165),
        ("ld2xst64p", 219..220),
        ("$mworker_ba", 58..59),
        ("f32v4ac", 210..211),
        ("shrs", 267..268),
        ("$REPEAT_END", 17..18),
        ("f32v4t", 212..213),
        ("f16v2ad", 90..91),
        ("ug", 288..289),
        ("$fp", 39..40),
        ("f32ex", 163..165),
        ("ld2x6", 218..219),
        ("st64step", 281..282),
        ("bitrev", 68..69),
        ("f16v2c", 91..100),
        ("shuf8x8l", 269..270),
        ("$COUNT_", 1..3),
        ("$VERTEX_", 20..21),
        ("f32v2suf", 207..208),
        ("$REPEAT_C", 16..17),
        ("s", 264..286),
        ("bitr", 68..69),
        ("$mworke", 58..59),
        ("ld128st", 217..218),
        ("f32in", 167..168),
        ("rp", 261..262),
        ("a", 61..68),
        ("f32v2absad", 186..187),
        ("f16v2cm", 93..100),
        ("shuf8x8h", 268..269),
        ("f16v2abs", 88..90),
        ("$CCCSLOA", 0..1),
        ("f32v2ax", 190..191),
        ("ldz8", 243..245),
        ("lds16step", 237..238),
        ("f32cmpeq", 156..157),
        ("$a1", 25..28),
        ("not6", 252..253),
        ("f16v4cmple", 127..128),
        ("cmps", 80..81),
        ("f16v2sufromu", 112..113),
        ("ld32st", 221..222),
        ("f32div", 162..163),
        ("f16v4sum", 147..148),
        ("$mworker_b", 58..59),
        ("f16v2absadd", 88..89),
        ("$PRNG_", 11..16),
        ("$mworker_bas", 58..59),
        ("f16v4cmpe", 124..125),
        ("st64", 279..282),
        ("f16v2cl", 91..93),
        ("ld2xst64pac", 219..220),
        ("ld2x64pace", 218..219),
        ("$PRNG_SE", 15..16),
        ("f16v4r", 139..140),
        ("ld32step", 221..222),
        ("ld64b16pac", 225..226),
        ("f32v2min", 203..204),
        ("bri", 70..71),
        ("f32sisoa", 177..178),
        ("f32v2gr", 200..201),
        ("sort4x16", 270..272),
        ("f16v4mul", 138..139),
        ("f16v4is", 133..134),
        ("f32sub", 180..181),
        ("f16v4sisoam", 142..143),
        ("f16v4ista", 133..134),
        ("ldz8step", 244..245),
        ("f16v4m", 134..139),
        ("ld1", 215..218),
        ("$m1", 42..49),
        ("f32v4a", 209..211),
        ("f32oorx", 174..175),
        ("f16v2gr", 103..104),
        ("ldd16b1", 234..235),
        ("sh", 265..270),
        ("f32v2a", 186..191),
        ("$mw", 58..59),
        ("f16v4ga", 130..131),
        ("cmpe", 78..79),
        ("f32from", 165..167),
        ("f32i", 167..168),
        ("$mz", 59..60),
        ("cmpsl", 80..81),
        ("stm32st", 283..284),
        ("f32sqr", 179..180),
        ("$FP_I", 8..9),
        ("an", 63..67),
        ("c", 76..83),
        ("ldd16v2a3", 235..236),
        ("f16v4siho", 140..142),
        ("f16v4sufromu", 146..147),
        ("f16v2sum", 113..114),
        ("$mvertex_bas", 57..58),
        ("ldz16s", 242..243),
        ("ld64b16pa", 225..226),
        ("f32v2ao", 189..190),
        ("ldst6", 240..241),
        ("$mzero", 59..60),
        ("f16v2gra", 103..104),
        ("ld12", 215..218),
        ("shuf8", 268..270),
        ("cal", 76..77),
        ("ldd16b16", 234..235),
        ("call", 76..77),
        ("f32mac", 170..171),
        ("r", 257..264),
        ("$DBG_BRK_I", 4..5),
        ("f32mi", 172..173),
        ("$az", 37..39),
        ("$PRNG_0_", 11..13),
        ("f16v2gi", 102..103),
        ("st64pace", 280..281),
        ("f32cmpe", 156..157),
        ("ld2xst64", 219..220),
        ("brneg", 71..72),
        ("get", 214..215),
        ("ldb1", 228..231),
        ("f16v4ab", 116..119),
        ("f16v4cmplt", 128..129),
        ("st64ste", 281..282),
        ("f16v2cmpg", 95..97),
        ("$lr", 40..41),
        ("$PRNG_1", 13..15),
        ("f32oox", 175..176),
        ("swap8", 285..286),
        ("cmpne", 79..80),
        ("shuf8x8", 268..270),
        ("$VERTEX_BAS", 20..21),
        ("ld64a", 223..225),
        ("f32fromi", 165..166),
        ("f16v4", 116..148),
        ("brpo", 74..75),
        ("$FP_CL", 6..7),
        ("tapack", 286..287),
        ("f32log2", 169..170),
        ("f32ab", 151..153),
        ("f16v2mu", 109..110),
        ("ld2xs", 219..220),
        ("f32v2s", 206..208),
        ("xor", 293..294),
        ("f32tan", 182..183),
        ("o", 253..255),
        ("$REPEA", 16..19),
        ("f16v4ist", 133..134),
        ("f32oo", 174..176),
        ("uget", 288..289),
        ("f16v4cmpne", 129..130),
        ("f16v4istacc", 133..134),
        ("$PRN", 11..16),
        ("f32log", 169..170),
        ("ldd16b", 234..235),
        ("f16v2tof32", 115..116),
        ("abs", 61..62),
        ("f16v2exp", 100..102),
        ("f32v2clas", 192..193),
        ("$FP_", 6..10),
        ("ld2xst64pa", 219..220),
        ("f16v2absa", 88..89),
        ("ld2xst", 219..220),
        ("f16v2ta", 114..115),
        ("$a", 23..39),
        ("f32v2mu", 204..205),
        ("f16v2cmpge", 95..96),
        ("pu", 256..257),
        ("f16v2log", 105..106),
        ("$VERTEX_BASE", 20..21),
        ("ldst64pa", 240..241),
        ("st6", 279..282),
        ("shuf8x8lo", 269..270),
        ("$TA", 19..20),
        ("ld64putcs", 226..227),
        ("ld2xst64pace", 219..220),
        ("f32", 151..213),
        ("sort8x8hi", 275..276),
        ("f32cla", 154..156),
        ("not", 251..253),
        ("$m13", 46..47),
        ("f16v2min", 108..109),
        ("runa", 263..264),
        ("or", 253..255),
        ("f16v2absma", 89..90),
        ("f32v4sqac", 211..212),
    ],
};

pub struct SignatureDef<'a> {
    pub label: &'a str,
    pub documentation: &'a str,
    pub parameters: &'a [SignatureParam<'a>],
}

pub struct SignatureParam<'a> {
    pub label: &'a str,
    pub documentation: &'a str,
}

pub static SIGNATURES: phf::Map<&'static str, &'static [SignatureDef<'static>]> = ::phf::Map {
    key: 12913932095322966823,
    disps: &[
        (0, 85),
        (0, 61),
        (0, 29),
        (0, 24),
        (0, 185),
        (0, 15),
        (0, 134),
        (0, 59),
        (0, 66),
        (0, 0),
        (0, 194),
        (0, 2),
        (1, 107),
        (0, 184),
        (0, 0),
        (0, 178),
        (0, 76),
        (0, 143),
        (0, 66),
        (0, 32),
        (3, 198),
        (3, 162),
        (0, 1),
        (33, 46),
        (4, 114),
        (0, 86),
        (1, 133),
        (0, 80),
        (19, 63),
        (48, 142),
        (0, 127),
        (0, 3),
        (0, 176),
        (18, 181),
        (0, 67),
        (0, 0),
        (0, 32),
        (2, 0),
        (0, 2),
        (1, 28),
        (0, 0),
        (0, 60),
        (5, 80),
        (7, 167),
        (0, 83),
        (2, 99),
    ],
    entries: &[
        ("f32v2gina", &[SignatureDef { label: "f32v2gina $aDst0:Dst0+1 $aSrc0:Src0+1 zimm12", documentation: "Get and initialise accumulators\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("f32class", &[SignatureDef { label: "f32class $aDst0 $aSrc0", documentation: "*Single-precision* floating-point number classifier\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("sort4x32hi", &[SignatureDef { label: "sort4x32hi $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "4 x 32-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("exitneg", &[SignatureDef { label: "exitneg $mSrc0", documentation: "Worker thread termination\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("f16v4absacc", &[SignatureDef { label: "f16v4absacc $aSrc0:Src0+1", documentation: "*Half-precision* vector accumulation of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("f16v8absacc", &[SignatureDef { label: "f16v8absacc $aSrc0:Src0+3", documentation: "*Half-precision* 8-element vector accumulation of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+3", documentation: "" }, ] }, ]),
        ("brnz", &[SignatureDef { label: "brnz $mSrc0 zimm19", documentation: "Branch if not zero\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm19", documentation: "" }, ] }, ]),
        ("ldb16", &[SignatureDef { label: "ldb16 $aDst0 $mBase0 $mDelta0 $mOff0", documentation: "16-bit load and broadcast\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "ldb16 $aDst0 $mBase0 $mDelta0 zimm12", documentation: "16-bit load and broadcast\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("run", &[SignatureDef { label: "run $mEntry0 $mVBase0 zimm16", documentation: "Launch a worker thread\n\n\n", parameters: &[SignatureParam { label: "$mEntry0", documentation: "" }, SignatureParam { label: "$mVBase0", documentation: "" }, SignatureParam { label: "zimm16", documentation: "" }, ] }, ]),
        ("roll8r", &[SignatureDef { label: "roll8r $mDst0 $mSrc0 $mSrc1", documentation: "roll8-right SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("f32v2tof16", &[SignatureDef { label: "f32v2tof16 $aDst0 $aSrc0:Src0+1", documentation: "*Single-precision* pair to *f16* pair\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("f32exp2", &[SignatureDef { label: "f32exp2 $aDst0 $aSrc0", documentation: "", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v4sihoslic", &[SignatureDef { label: "f16v4sihoslic $aDst0 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*Half-precision* floating-point vector slim convolution\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("swap8", &[SignatureDef { label: "swap8 $mDst0 $mSrc0", documentation: "4 x 8-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("f16v4cmple", &[SignatureDef { label: "f16v4cmple $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector less-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmple $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* vector less-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmple $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* vector less-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("and", &[SignatureDef { label: "and $mDst0 $mSrc0 $mSrc1", documentation: "32-bit bitwise logical AND\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "and $mDst0 $mSrc0 zimm12", documentation: "32-bit bitwise logical AND\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, SignatureDef { label: "and $aDst0 $aSrc0 $aSrc1", documentation: "32-bit bitwise logical AND\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "and $aDst0 $aSrc0 zimm12", documentation: "32-bit bitwise logical AND\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, SignatureDef { label: "and $aDst0 $aSrc0 immz12", documentation: "32-bit bitwise logical AND\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "immz12", documentation: "" }, ] }, ]),
        ("st32", &[SignatureDef { label: "st32 $aSrc0 $mBase0 $mDelta0 $mOffset0", documentation: "32-bit store\n\n\n", parameters: &[SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOffset0", documentation: "" }, ] }, SignatureDef { label: "st32 $mSrc0 $mBase0 $mDelta0 zimm12", documentation: "32-bit store\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, SignatureDef { label: "st32 $aSrc0 $mBase0 $mDelta0 zimm12", documentation: "32-bit store\n\n\n", parameters: &[SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("popc", &[SignatureDef { label: "popc $mDst0 $mSrc0", documentation: "Population count\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("stm32", &[SignatureDef { label: "stm32 $mSrc0 $mBase0 $mOffset0", documentation: "32-bit store from MRF\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mOffset0", documentation: "" }, ] }, ]),
        ("exitnz", &[SignatureDef { label: "exitnz $mSrc0", documentation: "Worker thread termination\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("lds8", &[SignatureDef { label: "lds8 $mDst0 $mBase0 $mDelta0 $mOff0", documentation: "Sign extending 8-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "lds8 $mDst0 $mBase0 $mDelta0 zimm12", documentation: "Sign extending 8-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("f32tanh", &[SignatureDef { label: "f32tanh $aDst0 $aSrc0", documentation: "*Single-precision* floating-point hyperbolic tangent\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32v4sqacc", &[SignatureDef { label: "f32v4sqacc $aSrc0:Src0+3", documentation: "*Single-precision* vector accumulate squares\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+3", documentation: "" }, ] }, ]),
        ("exitz", &[SignatureDef { label: "exitz $mSrc0", documentation: "Worker thread termination\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("st32step", &[SignatureDef { label: "st32step $mSrc0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing 32-bit store\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "st32step $aSrc0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing 32-bit store\n\n\n", parameters: &[SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "st32step $aSrc0 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing 32-bit store\n\n\n", parameters: &[SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("f32sigm", &[SignatureDef { label: "f32sigm $aDst0 $aSrc0", documentation: "", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32absmax", &[SignatureDef { label: "f32absmax $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point max of absolute values\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32v4tof16", &[SignatureDef { label: "f32v4tof16 $aDst0:Dst0+1 $aSrc0:Src0+3", documentation: "*Single-precision* 4-element vector to *f16* vector\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+3", documentation: "" }, ] }, ]),
        ("sort8x8hi", &[SignatureDef { label: "sort8x8hi $mDst0 $mSrc0 $mSrc1", documentation: "8 x 8-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("ldst64pace", &[SignatureDef { label: "ldst64pace $aDst0:Dst0+1 $aSrc0:Src0+1 $mAddr0:Addr0+1+= $mStride0 Strimm2x2", documentation: "Post-incrementing 64-bit load with simultaneous 64-bit store.\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$mAddr0:Addr0+1+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, SignatureParam { label: "Strimm2x2", documentation: "" }, ] }, ]),
        ("f16v2cmac", &[SignatureDef { label: "f16v2cmac $aSrc0 $aSrc1", documentation: "*Half-precision* vector multiply with lateral sum and accumulate\n\n\n", parameters: &[SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v2class", &[SignatureDef { label: "f16v2class $aDst0 $aSrc0", documentation: "*Half-precision* floating-point vector classifier\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v4sihoamp", &[SignatureDef { label: "f16v4sihoamp $aDst0 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*Half-precision* floating-point vector accumulating matrix-vector\nproduct\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("f32int", &[SignatureDef { label: "f32int $aDst0 $aSrc1 enumRnd", documentation: "round to integral\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, SignatureParam { label: "enumRnd", documentation: "" }, ] }, ]),
        ("ldz16", &[SignatureDef { label: "ldz16 $mDst0 $mBase0 $mDelta0 $mOff0", documentation: "Zero-extending 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "ldz16 $mDst0 $mBase0 $mDelta0 zimm12", documentation: "Zero-extending 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("st64pace", &[SignatureDef { label: "st64pace $aSrc0:Src0+1 $mAddr0:Addr0+1+= $mStride0 Strimm2", documentation: "Post-incrementing 64-bit store, using packed addresses and offsets\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$mAddr0:Addr0+1+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, SignatureParam { label: "Strimm2", documentation: "" }, ] }, ]),
        ("f32clamp", &[SignatureDef { label: "f32clamp $aDst0 $aSrc0 $aSrc1:Src1+1", documentation: "*Single-precision* floating-point vector min-of-maximum\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f32sqrt", &[SignatureDef { label: "f32sqrt $aDst0 $aSrc0", documentation: "Single precision square root\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32fromi32", &[SignatureDef { label: "f32fromi32 $aDst0 $aSrc0", documentation: "Signed integer to :term:\\'single-precision\\` floating-point conversion\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("ldz16step", &[SignatureDef { label: "ldz16step $mDst0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing zero-extending 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "ldz16step $mDst0 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing zero-extending 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("ldd16b16", &[SignatureDef { label: "ldd16b16 $aDst0 $mAddr0++ $mBase0 $mDelta0@", documentation: "Post-incrementing 16-bit delta and broadcast 16-bit data load\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mAddr0++", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0@", documentation: "" }, ] }, ]),
        ("tapack", &[SignatureDef { label: "tapack $mDst0:Dst0+1 $mAddr0 $mAddr1 $mAddr2", documentation: "Triple address pack\n\n\n", parameters: &[SignatureParam { label: "$mDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$mAddr0", documentation: "" }, SignatureParam { label: "$mAddr1", documentation: "" }, SignatureParam { label: "$mAddr2", documentation: "" }, ] }, ]),
        ("f16v2exp2", &[SignatureDef { label: "f16v2exp2 $aDst0 $aSrc0", documentation: "Base 2 exponential\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("ldd16a64", &[SignatureDef { label: "ldd16a64 $aDst0:Dst0+1 $mAddr0++ $mBase0 $mDelta0@", documentation: "Post-incrementing 16-bit delta and 64-bit data load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$mAddr0++", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0@", documentation: "" }, ] }, ]),
        ("uput", &[SignatureDef { label: "uput zimm8 $aSrc0", documentation: "Write to an upper control register\n\n\n", parameters: &[SignatureParam { label: "zimm8", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("ldd16v2a32", &[SignatureDef { label: "ldd16v2a32 $aDst0 $mAddr0++ $mBase0 $mDelta0@", documentation: "Post-incrementing delta-pair plus 32-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mAddr0++", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0@", documentation: "" }, ] }, ]),
        ("roll32", &[SignatureDef { label: "roll32 $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "roll32 SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("get", &[SignatureDef { label: "get $mDst0 zimm8", documentation: "Lower control register read\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "zimm8", documentation: "" }, ] }, ]),
        ("f32v2sufromui", &[SignatureDef { label: "f32v2sufromui $aDst0:Dst0+1 $aSrc0:Src0+1", documentation: "", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("f32v4absacc", &[SignatureDef { label: "f32v4absacc $aSrc0:Src0+3", documentation: "*Single-precision* vector accumulation of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+3", documentation: "" }, ] }, ]),
        ("ld64step", &[SignatureDef { label: "ld64step $aDst0:Dst0+1 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing 64-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "ld64step $aDst0:Dst0+1 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing 64-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("ld128putcs", &[SignatureDef { label: "ld128putcs zimm8", documentation: "128-bit load and put to common configuration space\n\n\n", parameters: &[SignatureParam { label: "zimm8", documentation: "" }, ] }, ]),
        ("shuf8x8lo", &[SignatureDef { label: "shuf8x8lo $mDst0 $mSrc0 $mSrc1", documentation: "8 x 8-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("not", &[SignatureDef { label: "not $aDst0 $aSrc0", documentation: "32-bit bitwise logical NOT\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32v4acc", &[SignatureDef { label: "f32v4acc $aSrc0:Src0+3", documentation: "*Single-precision* vector accumulate\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+3", documentation: "" }, ] }, ]),
        ("f16v2mul", &[SignatureDef { label: "f16v2mul $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* 2-element vector Hadamard product\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2mul $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* 2-element vector Hadamard product\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2mul $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* 2-element vector Hadamard product\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v4min", &[SignatureDef { label: "f16v4min $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector minimum\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("xor", &[SignatureDef { label: "xor $mDst0 $mSrc0 $mSrc1", documentation: "Bitwise XOR\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("ldz8step", &[SignatureDef { label: "ldz8step $mDst0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing *zero extended* 8-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "ldz8step $mDst0 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing *zero extended* 8-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("f32v2cmpgt", &[SignatureDef { label: "f32v2cmpgt $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector greater-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2cmpgt $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector greater-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v4cmpne", &[SignatureDef { label: "f16v4cmpne $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector inequality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmpne $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* vector inequality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmpne $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* vector inequality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f32toui32", &[SignatureDef { label: "f32toui32 $aDst0 $aSrc0", documentation: "*Single-precision* floating-point to unsigned integer conversion\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v4istacc", &[SignatureDef { label: "f16v4istacc $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "Sort/shuffle (permute) through accumulators, with new input\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("f16v2cmpgt", &[SignatureDef { label: "f16v2cmpgt $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector greater-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmpgt $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* floating-point vector greater-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmpgt $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* floating-point vector greater-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("uget", &[SignatureDef { label: "uget $aDst0 zimm8", documentation: "Upper control register read\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "zimm8", documentation: "" }, ] }, ]),
        ("f16v4max", &[SignatureDef { label: "f16v4max $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* 4-element vector max\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v2sum", &[SignatureDef { label: "f16v2sum $aDst0 $aSrc0", documentation: "*Half-precision* vector lateral summation\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32mac", &[SignatureDef { label: "f32mac $aSrc0 $aSrc1", documentation: "Single precision floating-point multiply and accumulate\n\n\n", parameters: &[SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32v2aop", &[SignatureDef { label: "f32v2aop $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*Single-precision* vector accumulating outer-product\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("rpt", &[SignatureDef { label: "rpt $mSrc0 zimm8", documentation: "Repeat a sequence of *Execution Bundle*s\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm8", documentation: "" }, ] }, SignatureDef { label: "rpt zimm12 zimm8", documentation: "Repeat a sequence of *Execution Bundle*s\n\n\n", parameters: &[SignatureParam { label: "zimm12", documentation: "" }, SignatureParam { label: "zimm8", documentation: "" }, ] }, ]),
        ("clz", &[SignatureDef { label: "clz $mDst0 $mSrc0", documentation: "Count leading zero bits\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("f16v4stacc", &[SignatureDef { label: "f16v4stacc $aDst0:Dst0+1 enumFlags", documentation: "Sort/shuffle (permute) through accumulators (no new input)\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("atom", &[SignatureDef { label: "atom $mDst0 $aSrc0", documentation: "Copy an *arf* register value to *mrf*\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v4rmask", &[SignatureDef { label: "f16v4rmask $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1", documentation: "*Half-precision* vector random mask\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32v2clamp", &[SignatureDef { label: "f32v2clamp $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* floating-point vector min-of-maximum\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f32v2min", &[SignatureDef { label: "f32v2min $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector min\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f32tof16", &[SignatureDef { label: "f32tof16 $aDst0 $aSrc0", documentation: "", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("sort4x16lo", &[SignatureDef { label: "sort4x16lo $mDst0 $mSrc0 $mSrc1", documentation: "4 x 16-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "sort4x16lo $aDst0 $aSrc0 $aSrc1", documentation: "4 x 16-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "sort4x16lo $aDst0 $aSrc0:BU $aSrc1", documentation: "4 x 16-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32v2sub", &[SignatureDef { label: "f32v2sub $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector subtraction\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2sub $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector subtraction\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f32ln", &[SignatureDef { label: "f32ln $aDst0 $aSrc0", documentation: "", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v4sisoamp", &[SignatureDef { label: "f16v4sisoamp $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*f16* accumulating matrix-vector product\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("f32v2cmple", &[SignatureDef { label: "f32v2cmple $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector less-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2cmple $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector less-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("stm32step", &[SignatureDef { label: "stm32step $mSrc0 $mBase0+= $mStride0", documentation: "Post-incrementing 32-bit store from MRF\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mBase0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("ld128step", &[SignatureDef { label: "ld128step $aDst0:Dst0+3 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing 128-bit load from interleaved memory region.\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+3", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "ld128step $aDst0:Dst0+3 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing 128-bit load from interleaved memory region.\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+3", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("ldd16a32", &[SignatureDef { label: "ldd16a32 $aDst0 $mAddr0++ $mBase0 $mDelta0@", documentation: "Post-incrementing 16-bit delta and 32-bit data load\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mAddr0++", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0@", documentation: "" }, ] }, ]),
        ("setzi", &[SignatureDef { label: "setzi $mDst0 zimm20", documentation: "Register set from immediate\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "zimm20", documentation: "" }, ] }, SignatureDef { label: "setzi $aDst0 zimm20", documentation: "Register set from immediate\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "zimm20", documentation: "" }, ] }, ]),
        ("f32div", &[SignatureDef { label: "f32div $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point division\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32oorx", &[SignatureDef { label: "f32oorx $aDst0 $aSrc0", documentation: "Floating-point reciprocal of square-root\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v2add", &[SignatureDef { label: "f16v2add $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector add\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2add $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* floating-point vector add\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2add $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* floating-point vector add\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v4maxc", &[SignatureDef { label: "f16v4maxc $aDst0 $aSrc0:Src0+1", documentation: "*Half-precision* vector 2x2 lateral max\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("exitpos", &[SignatureDef { label: "exitpos $mSrc0", documentation: "Worker thread termination\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("f32cmplt", &[SignatureDef { label: "f32cmplt $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point less than\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("ld32step", &[SignatureDef { label: "ld32step $mDst0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing *word* load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "ld32step $mDst0 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing *word* load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, SignatureDef { label: "ld32step $aDst0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing *word* load\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "ld32step $aDst0 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing *word* load\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("sort4x16hi", &[SignatureDef { label: "sort4x16hi $mDst0 $mSrc0 $mSrc1", documentation: "4 x 16-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "sort4x16hi $aDst0 $aSrc0 $aSrc1", documentation: "4 x 16-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "sort4x16hi $aDst0 $aSrc0:BL $aSrc1", documentation: "4 x 16-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32v2max", &[SignatureDef { label: "f32v2max $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector max\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v2cmpge", &[SignatureDef { label: "f16v2cmpge $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector greater-than-or-equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmpge $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* floating-point vector greater-than-or-equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmpge $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* floating-point vector greater-than-or-equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32v2mac", &[SignatureDef { label: "f32v2mac $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector multiply and accumulate\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("ld64a32pace", &[SignatureDef { label: "ld64a32pace $aDst0:Dst0+1 $aDst1 $mAddr0:Addr0+1+= $mStride0 Strimm2x2", documentation: "Post-incrementing dual 64/32-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aDst1", documentation: "" }, SignatureParam { label: "$mAddr0:Addr0+1+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, SignatureParam { label: "Strimm2x2", documentation: "" }, ] }, ]),
        ("shl", &[SignatureDef { label: "shl $mDst0 $mSrc0 $mSrc1", documentation: "Logical shift left\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "shl $mDst0 $mSrc0 zimm12", documentation: "Logical shift left\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("mul", &[SignatureDef { label: "mul $mDst0 $mSrc0 $mSrc1", documentation: "Signed multiplication\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "mul $mDst0 $mSrc0 simm16", documentation: "Signed multiplication\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "simm16", documentation: "" }, ] }, ]),
        ("sub", &[SignatureDef { label: "sub $mDst0 $mSrc1 $mSrc0", documentation: "Subtraction\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, SignatureDef { label: "sub $mDst0 zimm16 $mSrc0", documentation: "Subtraction\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "zimm16", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, SignatureDef { label: "sub $mDst0 simm16 $mSrc0", documentation: "Subtraction\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "simm16", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("put", &[SignatureDef { label: "put zimm8 $mSrc0", documentation: "Write to a lower control register\n\n\n", parameters: &[SignatureParam { label: "zimm8", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("f16v4absmax", &[SignatureDef { label: "f16v4absmax $aDst0:Dst0+1 $aSrc1:Src1+1 $aSrc0:Src0+1", documentation: "*Half-precision* 4-element vector max of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("st64", &[SignatureDef { label: "st64 $aSrc0:Src0+1 $mBase0 $mDelta0 $mOffset0", documentation: "64-bit store\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOffset0", documentation: "" }, ] }, SignatureDef { label: "st64 $aSrc0:Src0+1 $mBase0 $mDelta0 zimm12", documentation: "64-bit store\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("andc", &[SignatureDef { label: "andc $mDst0 $mSrc0 $mSrc1", documentation: "32-bit bitwise logical AND Complement\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "andc $mDst0 $mSrc0 zimm12", documentation: "32-bit bitwise logical AND Complement\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, SignatureDef { label: "andc $aDst0 $aSrc0 $aSrc1", documentation: "32-bit bitwise logical AND Complement\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "andc $aDst0 $aSrc0 zimm12", documentation: "32-bit bitwise logical AND Complement\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, SignatureDef { label: "andc $aDst0 $aSrc0 immz12", documentation: "32-bit bitwise logical AND Complement\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "immz12", documentation: "" }, ] }, ]),
        ("f32cmpeq", &[SignatureDef { label: "f32cmpeq $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("ld32", &[SignatureDef { label: "ld32 $mDst0 $mBase0 $mDelta0 $mOff0", documentation: "Single 32-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "ld32 $aDst0 $mBase0 $mDelta0 $mOff0", documentation: "Single 32-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "ld32 $mDst0 $mBase0 $mDelta0 zimm12", documentation: "Single 32-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, SignatureDef { label: "ld32 $aDst0 $mBase0 $mDelta0 zimm12", documentation: "Single 32-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("roll8l", &[SignatureDef { label: "roll8l $mDst0 $mSrc0 $mSrc1", documentation: "roll8-left SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("f16v8sqacc", &[SignatureDef { label: "f16v8sqacc $aSrc0:Src0+3", documentation: "*Half-precision* vector accumulate squares\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+3", documentation: "" }, ] }, ]),
        ("f16v4clamp", &[SignatureDef { label: "f16v4clamp $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1", documentation: "*Half-precision* floating-point vector min-of-maximum\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v2cmplt", &[SignatureDef { label: "f16v2cmplt $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector less-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmplt $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* floating-point vector less-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmplt $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* floating-point vector less-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32exp", &[SignatureDef { label: "f32exp $aDst0 $aSrc0", documentation: "", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("not64", &[SignatureDef { label: "not64 $aDst0:Dst0+1 $aSrc0:Src0+1", documentation: "64-bit bitwise logical NOT\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("f16v4mix", &[SignatureDef { label: "f16v4mix $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* 4-element vector z = ax + y\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("urand32", &[SignatureDef { label: "urand32 $aDst0", documentation: "Uniform distribution, 32-bit random integer\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, ] }, ]),
        ("f16v4sub", &[SignatureDef { label: "f16v4sub $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector subtraction\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4sub $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* vector subtraction\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4sub $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* vector subtraction\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v2tanh", &[SignatureDef { label: "f16v2tanh $aDst0 $aSrc0", documentation: "", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v4hihoamp", &[SignatureDef { label: "f16v4hihoamp $aDst0 $aSrc0:Src0+1 $aSrc1 enumFlags", documentation: "*Half-precision* vector accumulating matrix-vector product\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("f16v4gacc", &[SignatureDef { label: "f16v4gacc $aDst0:Dst0+1", documentation: "Get accumulators\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, ] }, ]),
        ("shrs", &[SignatureDef { label: "shrs $mDst0 $mSrc0 $mSrc1", documentation: "Signed (arithmetic) shift right\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "shrs $mDst0 $mSrc0 zimm12", documentation: "Signed (arithmetic) shift right\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("ld64", &[SignatureDef { label: "ld64 $aDst0:Dst0+1 $mBase0 $mDelta0 $mOff0", documentation: "Single 64-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "ld64 $aDst0:Dst0+1 $mBase0 $mDelta0 zimm12", documentation: "Single 64-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("f32v2mul", &[SignatureDef { label: "f32v2mul $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector Hadamard product\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2mul $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector Hadamard product\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v4hihoslic", &[SignatureDef { label: "f16v4hihoslic $aDst0 $aSrc0:Src0+1 $aSrc1 enumFlags", documentation: "*Half-precision* slim convolution\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("ldz8", &[SignatureDef { label: "ldz8 $mDst0 $mBase0 $mDelta0 $mOff0", documentation: "Zero-extending 8-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "ldz8 $mDst0 $mBase0 $mDelta0 zimm12", documentation: "Zero-extending 8-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("ld2xst64pace", &[SignatureDef { label: "ld2xst64pace $aDst0:Dst0+3 $aSrc0:Src0+1 $mAddr0:Addr0+1+= $mStride0 Strimm3x2", documentation: "Post-incrementing dual 64-bit load with simultaneous 64-bit store.\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+3", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$mAddr0:Addr0+1+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, SignatureParam { label: "Strimm3x2", documentation: "" }, ] }, ]),
        ("f16v2max", &[SignatureDef { label: "f16v2max $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector max\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32v2rmask", &[SignatureDef { label: "f32v2rmask $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1", documentation: "*Single-precision* vector random mask\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("sort4x32lo", &[SignatureDef { label: "sort4x32lo $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "4 x 32-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("lds16step", &[SignatureDef { label: "lds16step $mDst0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing sign-extending 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "lds16step $mDst0 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing sign-extending 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("shuf8x8hi", &[SignatureDef { label: "shuf8x8hi $mDst0 $mSrc0 $mSrc1", documentation: "8 x 8-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("f32v2class", &[SignatureDef { label: "f32v2class $aDst0 $aSrc0:Src0+1", documentation: "*Single-precision* floating-point vector classifier\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("cmpeq", &[SignatureDef { label: "cmpeq $mDst0 $mSrc0 $mSrc1", documentation: "Equality test\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "cmpeq $mDst0 $mSrc0 zimm16", documentation: "Equality test\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm16", documentation: "" }, ] }, SignatureDef { label: "cmpeq $mDst0 $mSrc0 simm16", documentation: "Equality test\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "simm16", documentation: "" }, ] }, ]),
        ("f16v8acc", &[SignatureDef { label: "f16v8acc $aSrc0:Src0+3", documentation: "*Half-precision* 8-element vector accumulate\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+3", documentation: "" }, ] }, ]),
        ("f32v2cmpge", &[SignatureDef { label: "f32v2cmpge $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector greater-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2cmpge $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector greater-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f32sisoslic", &[SignatureDef { label: "f32sisoslic $aDst0:Dst0+1 $aSrc0 $aSrc1:Src1+1 enumFlags", documentation: "*Single-precision* floating-point slim convolution\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("f32v2grand", &[SignatureDef { label: "f32v2grand $aDst0:Dst0+1", documentation: "Gaussian distribution, 2-element *single-precision* random vector\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, ] }, ]),
        ("xnor", &[SignatureDef { label: "xnor $mDst0 $mSrc0 $mSrc1", documentation: "Bitwise NOT XOR\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("bitrev8", &[SignatureDef { label: "bitrev8 $mDst0 $mSrc0", documentation: "Byte-wise bit order reversal\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("ldb16b16", &[SignatureDef { label: "ldb16b16 $aDst0:Dst0+1 $mBase0 $mDelta0++ $mMiniD0&gt;&gt;", documentation: "Post-incrementing, lightly-sparse 16-bit with dense 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0++", documentation: "" }, SignatureParam { label: "$mMiniD0&gt;&gt;", documentation: "" }, ] }, ]),
        ("f32fromui32", &[SignatureDef { label: "f32fromui32 $aDst0 $aSrc0", documentation: "Unsigned integer to :term:\\'single-precision\\` floating-point conversion\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("br", &[SignatureDef { label: "br $mSrc0", documentation: "Unconditional absolute branch to register target\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("movz", &[SignatureDef { label: "movz $mSrcDst0 $mSrc0 $mSrc1", documentation: "Conditional move\n\n\n", parameters: &[SignatureParam { label: "$mSrcDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("or", &[SignatureDef { label: "or $mDst0 $mSrc0 $mSrc1", documentation: "Bitwise OR\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "or $mDst0 $mSrc0 zimm12", documentation: "Bitwise OR\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, SignatureDef { label: "or $mDst0 $mSrc0 immz12", documentation: "Bitwise OR\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "immz12", documentation: "" }, ] }, SignatureDef { label: "or $aDst0 $aSrc0 $aSrc1", documentation: "Bitwise OR\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "or $aDst0 $aSrc0 zimm12", documentation: "Bitwise OR\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, SignatureDef { label: "or $aDst0 $aSrc0 immz12", documentation: "Bitwise OR\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "immz12", documentation: "" }, ] }, ]),
        ("f16v4cmac", &[SignatureDef { label: "f16v4cmac $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector multiply with 2x2 lateral sum and accumulate\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("ld2x64pace", &[SignatureDef { label: "ld2x64pace $aDst0:Dst0+1 $aDst1:Dst1+1 $mAddr0:Addr0+1+= $mStride0 Strimm2x2", documentation: "Post-incrementing, dual 64-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aDst1:Dst1+1", documentation: "" }, SignatureParam { label: "$mAddr0:Addr0+1+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, SignatureParam { label: "Strimm2x2", documentation: "" }, ] }, ]),
        ("f16v2grand", &[SignatureDef { label: "f16v2grand $aDst0", documentation: "Gaussian distribution, 2-element *half-precision* random vector\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, ] }, ]),
        ("f32sufromui", &[SignatureDef { label: "f32sufromui $aDst0 $aSrc0", documentation: "", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("st64step", &[SignatureDef { label: "st64step $aSrc0:Src0+1 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing 64-bit store\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "st64step $aSrc0:Src0+1 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing 64-bit store\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("f32v2add", &[SignatureDef { label: "f32v2add $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector add\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2add $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector add\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v2tof32", &[SignatureDef { label: "f16v2tof32 $aDst0:Dst0+1 $aSrc0", documentation: "*f16* pair to *single-precision* pair\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("call", &[SignatureDef { label: "call $mDst0 zimm20", documentation: "Function call\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "zimm20", documentation: "" }, ] }, ]),
        ("sort8x8lo", &[SignatureDef { label: "sort8x8lo $mDst0 $mSrc0 $mSrc1", documentation: "8 x 8-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("f16v4sum", &[SignatureDef { label: "f16v4sum $aDst0:Dst0+1 $aSrc0:Src0+1", documentation: "*Half-precision* vector 2x2 lateral summation\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("brnzdec", &[SignatureDef { label: "brnzdec $mSrcDst0 zimm19", documentation: "Branch if not zero, with counter decrement\n\n\n", parameters: &[SignatureParam { label: "$mSrcDst0", documentation: "" }, SignatureParam { label: "zimm19", documentation: "" }, ] }, ]),
        ("f32v2axpy", &[SignatureDef { label: "f32v2axpy $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* 2-element vector z = ax + y\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("ld128", &[SignatureDef { label: "ld128 $aDst0:Dst0+3 $mBase0 $mDelta0 $mOff0", documentation: "Single 128-bit load from interleaved memory region\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+3", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "ld128 $aDst0:Dst0+3 $mBase0 $mDelta0 zimm12", documentation: "Single 128-bit load from interleaved memory region\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+3", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("f16v4sisoslic", &[SignatureDef { label: "f16v4sisoslic $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1 enumFlags", documentation: "*f16* slim convolution\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("f16v4cmpeq", &[SignatureDef { label: "f16v4cmpeq $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmpeq $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* vector equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmpeq $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* vector equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("ld64putcs", &[SignatureDef { label: "ld64putcs zimm8", documentation: "64-bit load and put to common configuration space\n\n\n", parameters: &[SignatureParam { label: "zimm8", documentation: "" }, ] }, ]),
        ("brneg", &[SignatureDef { label: "brneg $mSrc0 zimm19", documentation: "Branch if negative\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm19", documentation: "" }, ] }, ]),
        ("f32sub", &[SignatureDef { label: "f32sub $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point subtract\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("cmpslt", &[SignatureDef { label: "cmpslt $mDst0 $mSrc0 $mSrc1", documentation: "Signed less-than test\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "cmpslt $mDst0 $mSrc0 simm16", documentation: "Signed less-than test\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "simm16", documentation: "" }, ] }, ]),
        ("f16v4sufromui", &[SignatureDef { label: "f16v4sufromui $aDst0:Dst0+1 $aSrc0:Src0+1", documentation: "", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("or64", &[SignatureDef { label: "or64 $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "64-bit bitwise logical OR\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v2sigm", &[SignatureDef { label: "f16v2sigm $aDst0 $aSrc0", documentation: "*Half-precision* 2-element vector logistic\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("sort8", &[SignatureDef { label: "sort8 $mDst0 $mSrc0", documentation: "4 x 8-bit SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("ldb16step", &[SignatureDef { label: "ldb16step $aDst0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing 16-bit load and broadcast\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "ldb16step $aDst0 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing 16-bit load and broadcast\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("max", &[SignatureDef { label: "max $mDst0 $mSrc0 $mSrc1", documentation: "Maximum\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "max $mDst0 $mSrc0 zimm16", documentation: "Maximum\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm16", documentation: "" }, ] }, SignatureDef { label: "max $mDst0 $mSrc0 simm16", documentation: "Maximum\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "simm16", documentation: "" }, ] }, ]),
        ("f32cmpge", &[SignatureDef { label: "f32cmpge $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point greater than or equal test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32v2cmplt", &[SignatureDef { label: "f32v2cmplt $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector less-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2cmplt $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector less-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v2cmpeq", &[SignatureDef { label: "f16v2cmpeq $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* vector equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmpeq $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* vector equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmpeq $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* vector equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32sisoamp", &[SignatureDef { label: "f32sisoamp $aDst0:Dst0+1 $aSrc0 $aSrc1:Src1+1 enumFlags", documentation: "*Single-precision* floating-point vector accumulating matrix-vector\nproduct\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "enumFlags", documentation: "" }, ] }, ]),
        ("f16v2absmax", &[SignatureDef { label: "f16v2absmax $aDst0 $aSrc1 $aSrc0", documentation: "*Half-precision* floating-point vector max of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16tof32", &[SignatureDef { label: "f16tof32 $aDst0 $aSrc0", documentation: "*f16* to *single-precision*\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v4cmpgt", &[SignatureDef { label: "f16v4cmpgt $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector greater-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmpgt $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* vector greater-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmpgt $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* vector greater-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f32toi32", &[SignatureDef { label: "f32toi32 $aDst0 $aSrc0", documentation: "*Single-precision* floating-point to signed integer conversion\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("lds8step", &[SignatureDef { label: "lds8step $mDst0 $mBase0 $mDelta0+= simm8", documentation: "Post-incrementing sign-extending 8-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "simm8", documentation: "" }, ] }, SignatureDef { label: "lds8step $mDst0 $mBase0 $mDelta0+= $mStride0", documentation: "Post-incrementing sign-extending 8-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, ] }, ]),
        ("f16v2cmpne", &[SignatureDef { label: "f16v2cmpne $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector inequality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmpne $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* floating-point vector inequality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmpne $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* floating-point vector inequality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v2absadd", &[SignatureDef { label: "f16v2absadd $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector add of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v4mul", &[SignatureDef { label: "f16v4mul $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* 4-element vector Hadamard product\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4mul $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* 4-element vector Hadamard product\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4mul $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* 4-element vector Hadamard product\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("cms", &[SignatureDef { label: "cms $mDst0 $mSrc0", documentation: "Count matching sign bits\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("abs", &[SignatureDef { label: "abs $mDst0 $mSrc0", documentation: "Absolute value of signed 32-bit integer\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, ] }, ]),
        ("roll16", &[SignatureDef { label: "roll16 $mDst0 $mSrc0 $mSrc1", documentation: "roll16 SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "roll16 $aDst0 $aSrc0 $aSrc1", documentation: "roll16 SIMD permutation\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v4cmpge", &[SignatureDef { label: "f16v4cmpge $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector greater-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmpge $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* vector greater-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmpge $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* vector greater-than or equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f16v4add", &[SignatureDef { label: "f16v4add $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector addition\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4add $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* vector addition\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4add $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* vector addition\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("bri", &[SignatureDef { label: "bri zimm19", documentation: "Unconditional absolute branch to immediate target\n\n\n", parameters: &[SignatureParam { label: "zimm19", documentation: "" }, ] }, ]),
        ("f16v4cmplt", &[SignatureDef { label: "f16v4cmplt $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector less-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmplt $aDst0:Dst0+1 $aSrc0:BL $aSrc1:Src1+1", documentation: "*Half-precision* vector less-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f16v4cmplt $aDst0:Dst0+1 $aSrc0:BU $aSrc1:Src1+1", documentation: "*Half-precision* vector less-than test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("runall", &[SignatureDef { label: "runall $mEntry0 $mVBase0 zimm16", documentation: "Launch a batch of worker threads\n\n\n", parameters: &[SignatureParam { label: "$mEntry0", documentation: "" }, SignatureParam { label: "$mVBase0", documentation: "" }, SignatureParam { label: "zimm16", documentation: "" }, ] }, ]),
        ("f16v4acc", &[SignatureDef { label: "f16v4acc $aSrc0:Src0+1", documentation: "*Half-precision* vector accumulate\n\n\n", parameters: &[SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("f16v2clamp", &[SignatureDef { label: "f16v2clamp $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector min-of-maximum\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("add", &[SignatureDef { label: "add $mDst0 $mSrc0 $mSrc1", documentation: "Integer addition\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "add $mDst0 $mSrc0 zimm16", documentation: "Integer addition\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm16", documentation: "" }, ] }, SignatureDef { label: "add $mDst0 $mSrc0 simm16", documentation: "Integer addition\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "simm16", documentation: "" }, ] }, ]),
        ("min", &[SignatureDef { label: "min $mDst0 $mSrc0 $mSrc1", documentation: "Minimum\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "min $mDst0 $mSrc0 zimm16", documentation: "Minimum\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm16", documentation: "" }, ] }, SignatureDef { label: "min $mDst0 $mSrc0 simm16", documentation: "Minimum\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "simm16", documentation: "" }, ] }, ]),
        ("f32cmpne", &[SignatureDef { label: "f32cmpne $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point not equal\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("ld64a32", &[SignatureDef { label: "ld64a32 $aDst0+1:Dst0+3 $mAddr0++ $mBase0 $mDelta0", documentation: "Post-incrementing dense 64-bit plus sparse 32-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0+1:Dst0+3", documentation: "" }, SignatureParam { label: "$mAddr0++", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, ] }, ]),
        ("f16v2maxc", &[SignatureDef { label: "f16v2maxc $aDst0 $aSrc0", documentation: "*Half-precision* vector lateral max\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v2log2", &[SignatureDef { label: "f16v2log2 $aDst0 $aSrc0", documentation: "*Half-precision* floating-point vector base 2 logarithm\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("urand64", &[SignatureDef { label: "urand64 $aDst0:Dst0+1", documentation: "Uniform distribution, 64-bit random integer\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, ] }, ]),
        ("cmpult", &[SignatureDef { label: "cmpult $mDst0 $mSrc0 $mSrc1", documentation: "Unsigned less-than test\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "cmpult $mDst0 $mSrc0 zimm16", documentation: "Unsigned less-than test\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm16", documentation: "" }, ] }, ]),
        ("and64", &[SignatureDef { label: "and64 $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "64-bit bitwise logical AND\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f32max", &[SignatureDef { label: "f32max $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point max\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v2exp", &[SignatureDef { label: "f16v2exp $aDst0 $aSrc0", documentation: "Natural exponential\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v4absadd", &[SignatureDef { label: "f16v4absadd $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Half-precision* vector addition of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("lds16", &[SignatureDef { label: "lds16 $mDst0 $mBase0 $mDelta0 $mOff0", documentation: "Sign extending 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "$mOff0", documentation: "" }, ] }, SignatureDef { label: "lds16 $mDst0 $mBase0 $mDelta0 zimm12", documentation: "Sign extending 16-bit load\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mBase0", documentation: "" }, SignatureParam { label: "$mDelta0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("f32v2absmax", &[SignatureDef { label: "f32v2absmax $aDst0:Dst0+1 $aSrc1:Src1+1 $aSrc0:Src0+1", documentation: "*Single-precision* vector max of absolute values\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("f32min", &[SignatureDef { label: "f32min $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point min\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("andc64", &[SignatureDef { label: "andc64 $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "64-bit bitwise logical AND Complement\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("cmpne", &[SignatureDef { label: "cmpne $mDst0 $mSrc0 $mSrc1", documentation: "Inequality test\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, ]),
        ("f32mul", &[SignatureDef { label: "f32mul $aDst0 $aSrc0 $aSrc1", documentation: "Single precision floating-point multiply\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32log2", &[SignatureDef { label: "f32log2 $aDst0 $aSrc0", documentation: "Base 2 logarithm\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32oox", &[SignatureDef { label: "f32oox $aDst0 $aSrc0", documentation: "Floating-point reciprocal\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v2cmple", &[SignatureDef { label: "f16v2cmple $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector less-than-or-equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmple $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* floating-point vector less-than-or-equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2cmple $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* floating-point vector less-than-or-equal-to test\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32v2cmpne", &[SignatureDef { label: "f32v2cmpne $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector inequality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2cmpne $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector inequality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f32add", &[SignatureDef { label: "f32add $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point addition\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32cmpgt", &[SignatureDef { label: "f32cmpgt $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point greater than\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("brpos", &[SignatureDef { label: "brpos $mSrc0 zimm19", documentation: "Branch if positive\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm19", documentation: "" }, ] }, ]),
        ("f16v2sufromui", &[SignatureDef { label: "f16v2sufromui $aDst0 $aSrc0", documentation: "", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f32v2absadd", &[SignatureDef { label: "f32v2absadd $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* floating-point vector add of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("f32absadd", &[SignatureDef { label: "f32absadd $aDst0 $aSrc0 $aSrc1", documentation: "Scalar floating-point addition of absolutes\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v2min", &[SignatureDef { label: "f16v2min $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector element-wise minimum\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v2ln", &[SignatureDef { label: "f16v2ln $aDst0 $aSrc0", documentation: "*Half-precision* floating-point vector natural logarithm\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, ] }, ]),
        ("f16v4class", &[SignatureDef { label: "f16v4class $aDst0 $aSrc0:Src0+1", documentation: "*Half-precision* floating-point vector classifier\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, ] }, ]),
        ("brz", &[SignatureDef { label: "brz $mSrc0 zimm19", documentation: "Branch if zero\n\n\n", parameters: &[SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm19", documentation: "" }, ] }, ]),
        ("f32cmple", &[SignatureDef { label: "f32cmple $aDst0 $aSrc0 $aSrc1", documentation: "Floating-point less or equal\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f32v2cmpeq", &[SignatureDef { label: "f32v2cmpeq $aDst0:Dst0+1 $aSrc0:Src0+1 $aSrc1:Src1+1", documentation: "*Single-precision* vector equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:Src0+1", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, SignatureDef { label: "f32v2cmpeq $aDst0:Dst0+1 $aSrc0:B $aSrc1:Src1+1", documentation: "*Single-precision* vector equality test\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aSrc0:B", documentation: "" }, SignatureParam { label: "$aSrc1:Src1+1", documentation: "" }, ] }, ]),
        ("ld64b16pace", &[SignatureDef { label: "ld64b16pace $aDst0:Dst0+1 $aDst1 $mAddr0:Addr0+1+= $mStride0 Strimm2x2", documentation: "Post-incrementing, dual 64/16-bit load\n\n\n", parameters: &[SignatureParam { label: "$aDst0:Dst0+1", documentation: "" }, SignatureParam { label: "$aDst1", documentation: "" }, SignatureParam { label: "$mAddr0:Addr0+1+=", documentation: "" }, SignatureParam { label: "$mStride0", documentation: "" }, SignatureParam { label: "Strimm2x2", documentation: "" }, ] }, ]),
        ("trap", &[SignatureDef { label: "trap zimm4", documentation: "Patched BREAKPOINT\n\n\n", parameters: &[SignatureParam { label: "zimm4", documentation: "" }, ] }, ]),
        ("f16v2sub", &[SignatureDef { label: "f16v2sub $aDst0 $aSrc0 $aSrc1", documentation: "*Half-precision* floating-point vector subtract\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2sub $aDst0 $aSrc0:BL $aSrc1", documentation: "*Half-precision* floating-point vector subtract\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BL", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, SignatureDef { label: "f16v2sub $aDst0 $aSrc0:BU $aSrc1", documentation: "*Half-precision* floating-point vector subtract\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0:BU", documentation: "" }, SignatureParam { label: "$aSrc1", documentation: "" }, ] }, ]),
        ("f16v2gina", &[SignatureDef { label: "f16v2gina $aDst0 $aSrc0 zimm12", documentation: "Get and initialise accumulators\n\n\n", parameters: &[SignatureParam { label: "$aDst0", documentation: "" }, SignatureParam { label: "$aSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
        ("shr", &[SignatureDef { label: "shr $mDst0 $mSrc0 $mSrc1", documentation: "Logical shift right\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "$mSrc1", documentation: "" }, ] }, SignatureDef { label: "shr $mDst0 $mSrc0 zimm12", documentation: "Logical shift right\n\n\n", parameters: &[SignatureParam { label: "$mDst0", documentation: "" }, SignatureParam { label: "$mSrc0", documentation: "" }, SignatureParam { label: "zimm12", documentation: "" }, ] }, ]),
    ],
};
